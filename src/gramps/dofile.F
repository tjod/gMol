C *************************************************************
C This file contains source code for the gMol computer program
C  Copyright (C) 1981-2010 by TJ O'Donnell and
C  Copyright (C) 2005-2010 gNova, Inc.
C It is unlawful to modify or remove this copyright notice.
C See the accompanying LICENSE file for further information. 
C *************************************************************
	Subroutine DOFILE(ARG)
C
	IMPLICIT NONE
C
#include "UDLIST.FOR"
#include "ERRORS.FOR"
#include "FILES.FOR"
#include "DOLLARGS.FOR"
#include "DEFVAL.FOR"
C
	CHARACTER ARG*(*)
	CHARACTER COMMAND*80
	CHARACTER*128 TMPLINE
	CHARACTER*1 BLANK
	CHARACTER*5 TAB
	CHARACTER*255 FILE
	EXTERNAL TRIM
	INTEGER ARGNUM, I, NEWAGF
	DATA TAB/'     '/
	DATA BLANK/' '/
	TAB='     '
	BLANK=' '
C
C	 THIS SUBROUTINE "DOES" A SEQUENCE OF COMMANDS FOUND
C	 IN A FILE.  IT IS CALLED EXPLICITLY WITH THE DO COMMAND
C	 OR IMPLICITLY WHEN A COMMAND NAME MATCH IS NOT FOUND.
C
C
C	 PARSE THE FILE NAME.  THE COLLECT STUFF HERE IS NECESSARY
C	 BECAUSE COMMANDS INSIDE OF .GIN FILES ARE NOT COLLECTED,
C	 THE THE COMMAND CAUSING THE .GIN FILE TO BE "DONE"
C	 MUST BE COLLECTED.
C	 SET THE DOING FLAG SO THAT COMMAND COLLECTING WILL BE
C	 SUSPENDED UNTIL SOCKOPEN RESETS THE FLAG TO .FALSE. THE
C	 NEXT TIME A COMMAND IS ENTERED FROM THE TERMINAL.
C
C	 GFILE COUNTS THE DEPTH OF CALL OF .GIN FILES
C
	ERROR=0
	GFILE=GFILE+1
	IF(GFILE.GT.GFILMAX)CALL TELLUSER(GFILEND,*999)
	POINT=1
	CALL GETSTR(ARG,POINT,FILE)
	DEFEXT='gin'
	ERROR=OPENFILE(FILE,GFILE,.FALSE.,' ')
	IF(ERROR.NE.0)THEN
	  POINT=1
	  GOTO 999
	END IF
	IF( COLLECT.AND.(.NOT.DOING).AND.(.NOT.SKIPCOLL) )
     &  WRITE(CFILE,1000)ARG(:TRIM(ARG))
	DOING=.TRUE.
C
C	 PICK OUT THE ARGUMENTS
C	 AND STORE THEM IN THE CORRECT SPOT.  THE ARGS MUST
C	 BE SAVED BECAUSE A .GIN FILE MAY CALL ANOTHER .GIN FILE
C	 WHICH ITSELF MAY USE ARGUMENTS.
C
	ARGNUM=0
	NEWAGF=GFILE-GFILMIN+2
 5    IF(POINT.NE.0)THEN
	  ARGNUM=ARGNUM+1
	  CALL GETSTR(ARG,POINT,ARGLIST(ARGNUM,NEWAGF))
	  IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
	  GOTO 5
	END IF
	DO 6 I=ARGNUM+1,ARGMAX
	ARGLIST(I,NEWAGF)(1:)=BLANK
 6    CONTINUE
c	write(*,*)'in dofile: tunits=',tunits(newagf),'was=',tunits(agf)
	tunits(newagf)=tunits(agf)
	AGF=NEWAGF
C
C	 READ THE FILE OF COMMANDS, ECHO THE COMMAND IF
C	 NECESSARY.  IF THERE ARE ANY ARGUMENTS, PERFORM THE
C	 SUBSTITUTION AND THEN "DO" THE COMMAND.
C	 THE DO SUBROUTINE
C	 CALLED ME AND I'M CALLING DO BACK.  SOUNDS LIKE
C	 RECURSIVE PROGRAMMING...AND IT IS EVEN THOUGH
C	 FORTRAN DOESN'T SUPPORT THAT.  THAT'S WHY I
C	 NEED TO SAVE ARGS ABOVE UP TO THE MAX LEVEL THAT
C	 .GIN FILES CAN BE NESTED.
C
C	 VERY TRICKY ENTRY POINT!
C	 IS USED BY HITTEST AFTER THE WAITING IS OVER.
C
        GOTO 10
	ENTRY DOMORE
C        write(*,*)'domore', agf, gfile
C
 10   CONTINUE
      READ(GFILE,1000,END=999,ERR=998)COMMAND
	IF(VERIFY)THEN
	  IF( (VERLVL.EQ.0).OR.(VERLVL.GE.AGF-1) )THEN
	    WRITE(TMPLINE,2000) (TAB,I=1,AGF-2),COMMAND(:TRIM(COMMAND))
	    CALL GROUT(TMPLINE)
	  END IF
	END IF
	I = DO(COMMAND)
	IF(WAITING.NE.0)THEN
	  RETURN
	Else IF(NADVANCE.GT.0)THEN
          Return
	ELSE
	  GOTO 10
	END IF
 1000 FORMAT(A)
 2000 FORMAT('#',14A)
C
C	 ALL DONE WITH THE FILE.  CLOSE IT AND POP UP A LEVEL
C	 IF WE'RE AT LEVEL 1, ALL GIN FILE NESTING IS
C	 FINISHED.  SET DOING OFF AND SET SKIPCOLL DO THAT
C	 THE LAST LINE OF THE FILE WILL NOT BE COLLECTED.
C
 998	Continue
	Call Telluser1(GFILERR)
C
 999  CONTINUE
	CLOSE (UNIT=GFILE)
	GFILE=GFILE-1
	NEWAGF=GFILE-GFILMIN+2
c	write(*,*)'end dofile: tunits=',tunits(newagf),'was=',tunits(agf)
	Call setunits(tunits(newagf))
	AGF=NEWAGF
	IF(AGF.EQ.1)THEN
	  DOING=.FALSE.
	  SKIPCOLL=.TRUE.
	END IF
	RETURN
C
	END
C
	Subroutine setunits(oldnew)
	Implicit None
	Integer oldnew
#include "UDLIST.FOR"
#include "ERRORS.FOR"
#include "DEFVAL.FOR"
	Integer i
c
C Restore UNITS of previous gin file level
	Do i=1,MTFM
	If(oldnew.EQ.OLDUNITS)Then
		UNITS(i)=OUNITS(i)
	Else If(oldnew.EQ.NEWUNITS)Then
		UNITS(i)=NUNITS(i)
	Else
		ERROR=NEVER
	End If
	End Do
c World, too.
	Do i=1,WTFM
	If(oldnew.EQ.OLDUNITS)Then
		WUNITS(i)=OWUNITS(i)
	Else If(oldnew.EQ.NEWUNITS)Then
		WUNITS(i)=NWUNITS(i)
	Else
		ERROR=NEVER
	End If
	End Do
C
	Return
	End
