C *************************************************************
C This file contains source code for the gMol computer program
C  Copyright (C) 1981-2010 by TJ O'Donnell and
C  Copyright (C) 2005-2010 gNova, Inc.
C It is unlawful to modify or remove this copyright notice.
C See the accompanying LICENSE file for further information. 
C *************************************************************
	SUBROUTINE GETVLU(ARG,SPOINT,VALL,ADDITT)
C
	IMPLICIT NONE
	INTEGER SPOINT, VALL
	LOGICAL ADDITT
C
#include "UDLIST.FOR"
#include "ERRORS.FOR"
	INTEGER VPOINT
	CHARACTER ARG*(*)
	CHARACTER  VALNAM*15,COMMA*1,DOT*1,BLANK*1
	CHARACTER  VALX*15
	COMMA=','
	DOT='.'
	BLANK=' '
C
C
C	 THIS IS A GRAMPS UTILITY SUBROUTINE WHICH PARSES
C	 A COMMAND STRING FOR A INTEGER VALUE.  IT RETURNS
C	 THE VALUE AND UPDATES THE POINTER IN THE COMMAND STRING.
C	 THE THE VALUE IS NO GOOD, THE ARG POINTER IS NOT CHANGED.
C
C	 SAVE THE ENTRY VALUE OF THE POINTER
C
	VPOINT=SPOINT
C
	CALL GETSTR(ARG,SPOINT,VALNAM)
	IF(ERROR.NE.0)GOTO 999
	IF(NPOINT.EQ.0)THEN
	  ERROR=INCOMP
	  GOTO 999
	END IF
C
	ADDITT=.FALSE.
	VALX=VALNAM(1:)
	VALL=A2I(VALX,ERROR)
C
C	 COME HERE IF THERE IS A ERROR TRANSLATING ASCII TO BINARY
C
 998  CONTINUE
	IF(ERROR.EQ.0)RETURN
	ERROR=VALERR
C
 999  CONTINUE
	SPOINT=VPOINT
	RETURN
C
	END
C
	SUBROUTINE GETVLX(ARG,SPOINT,VALL,ADDITT)
C
	IMPLICIT NONE
	INTEGER SPOINT
	REAL VALL
	LOGICAL ADDITT
C
#include "UDLIST.FOR"
#include "ERRORS.FOR"
	INTEGER VPOINT
	CHARACTER ARG*(*)
	CHARACTER  VALNAM*15,COMMA*1,DOT*1,BLANK*1,PLUS*2,MINUS*2
	CHARACTER  VALX*15
	COMMA=','
	BLANK=' '
	DOT='.'
	PLUS='.+'
	MINUS='.-'
C
C
C	 THIS IS A GRAMPS UTILITY SUBROUTINE WHICH PARSES
C	 A COMMAND STRING FOR A INTEGER VALUE.  IT RETURNS
C	 THE VALUE AND UPDATES THE POINTER IN THE COMMAND STRING.
C	 THE THE VALUE IS NO GOOD, THE ARG POINTER IS NOT CHANGED.
C
C	 SAVE THE ENTRY VALUE OF THE POINTER
C
	VPOINT=SPOINT
C
	CALL GETSTR(ARG,SPOINT,VALNAM)
	IF(ERROR.NE.0)GOTO 999
	IF(NPOINT.EQ.0)THEN
	  ERROR=INCOMP
	  GOTO 999
	END IF
C
C	 TRANSLATE THE VALUE TO A BINARY VALUE.
C	 IF THERE IS A DOT FOLLOWED BY + or - IN THE ASCII VALUE,
C	   FLAG THE FACT BY SETTING ADDIT=.TRUE.
C
	If(VALNAM.EQ.DOT)Then
	ADDIT=.TRUE.
	VALL=0.0
	Return
	Else If(VALNAM(1:2).EQ.PLUS .OR. VALNAM(1:2).EQ.MINUS)Then
	ADDITT=.TRUE.
	VALX=VALNAM(2:)
	ELSE
	  ADDITT=.FALSE.
	  VALX=VALNAM(1:)
	END IF
	VALL=A2F(VALX,ERROR)
C
C	 COME HERE IF THERE IS A ERROR TRANSLATING ASCII TO BINARY
C
 998  CONTINUE
	IF(ERROR.EQ.0)RETURN
	ERROR=VALERR
C
 999  CONTINUE
	SPOINT=VPOINT
	RETURN
C
	END
C
	INTEGER FUNCTION A2I(VALNAM,ERROR)
C
	IMPLICIT NONE
	CHARACTER VALNAM*(*)
	INTEGER ERROR
#include "ERRORS.FOR"
	CHARACTER VALID*12
	CHARACTER VALTMP*15
	INTEGER VAL, SIZE, I
	INTEGER TRIM
	EXTERNAL TRIM
	REAL FVAL
	VALID='0123456789-+'
C
	SIZE=TRIM(VALNAM)
	IF(SIZE.GE.LEN(VALTMP))GOTO 998
	DO 10 I=1,SIZE
	IF( INDEX(VALID,VALNAM(I:I)) .EQ. 0 ) GOTO 998
 10   CONTINUE
	VALTMP=VALNAM(:SIZE)//'.'
	READ(VALTMP,'(F15.0)',ERR=998)FVAL
	ERROR=0
	A2I=INT(FVAL)
	RETURN
C
 998  ERROR=VALERR
	A2I=0
	RETURN
C
	END
C
	REAL FUNCTION A2F(VALNAME,ERROR)
C
	IMPLICIT NONE
	CHARACTER VALNAME*(*)
	INTEGER ERROR
#include "ERRORS.FOR"
	REAL FVAL
	INTEGER IEND
	INTEGER TRIM
	EXTERNAL TRIM
	CHARACTER*15 VALX
C
	VALX=VALNAME
	IEND=TRIM(VALX)
	IF(IEND.EQ.0)THEN
	  GO TO 999
	ELSE
	  READ(VALX,1000,ERR=999)FVAL
	ENDIF
	ERROR=0
	A2F=FVAL
	RETURN
C
 999  CONTINUE
	ERROR=VALERR
	A2F=0.0
	RETURN
C
 1000 FORMAT(F15.0)
	END
