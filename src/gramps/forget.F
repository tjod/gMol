C *************************************************************
C This file contains source code for the gMol computer program
C  Copyright (C) 1981-2010 by TJ O'Donnell and
C  Copyright (C) 2005-2010 gNova, Inc.
C It is unlawful to modify or remove this copyright notice.
C See the accompanying LICENSE file for further information. 
C *************************************************************
      SUBROUTINE FORGET(ARG)
C
      IMPLICIT NONE
C
#include "UDLIST.FOR"
#include "ERRORS.FOR"
C
      CHARACTER ARG*(*)
C
      INTEGER IDNEW, ADDR, NEWA, MINID, MINFID, NEWID, NEWFID, I, J, K
      INTEGER START, FINISH, DEPTH, LEVEL
      INTEGER NEWSIZE
      INTEGER OBJLOC, OLDFID
      INTEGER TBASE,NEWAD,ADDRS,DELTA,NFREE,JAD
      INTEGER UDTO,UDFROM,DELSIZ
      LOGICAL PASSED
      DIMENSION NEWA(2),ADDR(2)
      EQUIVALENCE (ADDRS,ADDR),(NEWAD,NEWA)
      DIMENSION IDNEW(WORKSIZE)
      EQUIVALENCE (IDNEW, WORK)
C
      POINT=1
      CALL NAMID(ARG,POINT,ID)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
C
C       MARK THE REQUIRED OBJECTS FOR DELETION
C
      MINID=NOBJ
      MINFID=NIDS
      CALL DELMARK(ID,MINID,MINFID)
      NEWID=MINID-1
      NFREE=NEXTLOC(NEWID)
      NEWFID=MINFID-1
      DO 10 I=1,MINID
      IDNEW(I)=I
 10   CONTINUE
C
C       CLEAN UP ALL ENTRIES HAVING BEEN MARKED.
C
C       FOR EVERY OBJECT
C       FIX UP THE TREE AND...
C
      DO 100 I=MINID,NOBJ
      IF( BTEST(KINDOBJ(I),DELBIT) )THEN
        IF( .NOT.BTEST(KINDOBJ(I),MENUBIT) )THEN
          CALL GROUPINFO(I,START,FINISH,DEPTH,LEVEL,NEWSIZE)
          IF(TYPOBJ(I).EQ.GROUP)THEN
            DO 11 J=START,FINISH-1
 11         TREE(J)=TREE(J+1)
            DO 12 J=FINISH-1,TREEEND
 12         TREE(J)=TREE(J+2)
            TREEEND=TREEEND-2
          ELSE
            DO 13 J=FINISH,TREEEND
 13         TREE(J)=TREE(J+1)
            TREEEND=TREEEND-1
          END IF
        ELSE
          PASSED=.FALSE.
          DO 14 J=1,MENUEND
          IF(PASSED)THEN
            MENUTREE(J-1)=MENUTREE(J)
          ELSE
            IF(MENUTREE(J).EQ.I)PASSED=.TRUE.
          END IF      
 14       CONTINUE
          MENUEND=MENUEND-1
        END IF
        Call g0delobj(IDOBJ(I))
        IF(FRAMECHK(I))THEN
          DO 15 J=1,FRMCNT(I)
          Call g0delobj(IDOBJ(I)+J)
 15       CONTINUE
        End If
C
C       ... AND REARRANGE ITS PLACE IN THE DLIST (UDL) ARRAY
C
      ELSE
        IF(I.EQ.MASTSYN(I))THEN
          UDFROM=LOCOBJ(I)
          UDTO=NEXTLOC(I)-1
C         LOCOBJ(I)=ISIGN(NFREE,LOCOBJ(I))
          OBJLOC=NFREE
          DO 16 JAD=UDFROM,UDTO
          DLIST(NFREE)=DLIST(JAD)
          NFREE=NFREE+1
 16       CONTINUE
        ELSE
          OBJLOC=LOCOBJ(MASTSYN(I))
        END IF
C
C       ... AND REARRANGE THE LOCATION, SIZE, ETC. ARRAYS...
C
        NEWID=NEWID+1
C       LOCOBJ (NEWID)= LOCOBJ(I)
        KINDOBJ(NEWID)=KINDOBJ(I)
        NAMOBJ (NEWID)= NAMOBJ(I)
        IF(I.EQ.MASTSYN(I))THEN
          FRMCNT (NEWID)= FRMCNT(I)
          IDNEW(I)=NEWID
        ELSE
          FRMCNT(NEWID)=IDNEW(FRMCNT(I))
        END IF
C
C       ... AND REARRANGE LOCATION, SIZE OF FRAMES OWNED BY THE OBJECT
C       OR JUST REARRANGE THE SINGLE ID IF NOT A FRAMED OBJECT...
C
        IF(I.EQ.MASTSYN(I))THEN
          NEWFID=NEWFID+1
          OLDFID=IDOBJ(I)
          IDOBJ(NEWID)=NEWFID
          IF(FRAMECHK(I))THEN
C           OBJFRLOC(NEWFID)=ABS(LOCOBJ(NEWID))
            OBJFRLOC(NEWFID)=OBJLOC
            OBJFRSIZ(NEWFID)=OBJFRSIZ(OLDFID)
            OBJFRID (NEWFID)=OBJFRID (OLDFID)
            DO 17 J=1,FRMCNT(I)
            NEWAD=OBJFRLOC(NEWFID)+OBJFRSIZ(NEWFID)
            NEWFID=NEWFID+1
            OBJFRLOC(NEWFID)=NEWAD
            OBJFRSIZ(NEWFID)=OBJFRSIZ(OLDFID+J)
            OBJFRID (NEWFID)=OBJFRID (OLDFID+J)
 17         CONTINUE
          ELSE
C           OBJFRLOC(NEWFID)=LOCOBJ(NEWID)
            OBJFRLOC(NEWFID)=OBJLOC
            OBJFRSIZ(NEWFID)=OBJFRSIZ(OLDFID)
            OBJFRID (NEWFID)=OBJFRID (OLDFID)
          END IF
        ELSE
          IDOBJ(NEWID)=IDOBJ(FRMCNT(NEWID))
        END IF
C
C       ...AND REARRANGE ALL THE DEVUSE,FNUSE,ETC. ARRAYS
C
        DO 18 J=1,MTFM
        DEVUSE(J,NEWID)=DEVUSE(J,I)
        FNUSE(J,NEWID)=FNUSE(J,I)
        TFMVAL(J,NEWID)=TFMVAL(J,I)
        TFMINC(J,NEWID)=TFMINC(J,I)
        TFMANG(J,NEWID)=TFMANG(J,I)
        BOUNDS(J,NEWID)=BOUNDS(J,I)
        AMPL(J,NEWID)=AMPL(J,I)
        DFACT(J,NEWID)=DFACT(J,I)
 18     CONTINUE
        DEVUSE(SUMMARY,NEWID)=DEVUSE(SUMMARY,I)
        FNUSE(SUMMARY,NEWID)=FNUSE(SUMMARY,I)
C
C       AND REARRANGE ARBITRARY AXIS AND FIX MATRIX.
C
        DO 19 J=1,4
        DO 19 K=1,4
        ARBMAT (J,K,NEWID)=ARBMAT (J,K,I)
        IARBMAT(J,K,NEWID)=IARBMAT(J,K,I)
        FIXMAT (J,K,NEWID)=FIXMAT (J,K,I)
 19     CONTINUE
C
C     AND CORRECT THE APPROPRIATE TREE.
C
        IF(BTEST(KINDOBJ(I),MENUBIT))THEN
          DO 20 J=1,MENUEND
          IF(MENUTREE(J).EQ.I)MENUTREE(J)=NEWID
 20       CONTINUE
        ELSE
          DO 21 J=1,TREEEND
          IF(TREE(J).EQ.I)TREE(J)=NEWID
 21       CONTINUE
        END IF
C
      END IF
C
 100  CONTINUE
C
C       RECALCULATE SEVERAL SYSTEM VARAIBLE TO REFLECT DELETIONS.
C
      NOBJ=NEWID
      NIDS=NEWFID
      UDFREE=NFREE
      TCHANGE=.TRUE.
C
 999  RETURN
      END
C
      FUNCTION MASTSYN(NID)
C
      IMPLICIT NONE
      INTEGER NID
C
#include "UDLIST.FOR"
      INTEGER I
C
C       THIS ROUTINE RETURNS THE ID NUMBER OF THE MASTER
C       CORRESPONDING TO THE NID GIVEN.  THE RETURNED
C       ID MAY EQUAL NID, IN WHICH CASE THE SYNONYM IN
C       QUESTION IS THE MASTER ITSELF.
C
      IF( BTEST(KINDOBJ(NID),SYNOBIT) )THEN
        DO 10 I=1,NOBJ
        IF( IDOBJ(I).NE.IDOBJ(NID) )GOTO 10
        MASTSYN=I
        RETURN
 10     CONTINUE
      ELSE
        MASTSYN=NID
        RETURN
      END IF
C
C       THIS SHOULD NEVER HAPPEN.
C
      MASTSYN=0
      RETURN
C
      END
C
      FUNCTION NEXTLOC(NID)
C
      IMPLICIT NONE
      INTEGER NID
C
      INTEGER I
#include "UDLIST.FOR"
C
C       THIS FUNCTION RETURNS THE LOCATION IN DLIST
C       OF THE NEXT OBJECT WHICH HAS A LOCATION
C       IN DLIST ASSOCIATED WITH IT.  
C
      IF(NID.LT.NOBJ)THEN
        DO 10 I=NID+1,NOBJ
        IF( LOCOBJ(I).LE.LOCOBJ(NID) )GOTO 10
        NEXTLOC=LOCOBJ(I)
        RETURN
 10     CONTINUE
      END IF
C
      NEXTLOC=UDFREE
      RETURN
      END
C
      SUBROUTINE DELMARK(NID,MINID,MINFID)
C
      IMPLICIT NONE
      INTEGER NID, MINID, MINFID
      INTEGER I
C
#include "UDLIST.FOR"
C
C       MARK THIS OBJECT FOR DELETION.  IF ITS A SYNONYM MASTER,
C       MARK ALL THE REFERENCES FOR DELETION, TOO.
C
      IF( BTEST(KINDOBJ(NID),SYNOBIT).AND.(MASTSYN(NID).EQ.NID) )THEN
        CALL RMOBJ(NID,MINID,MINFID)
        DO 20 I=NID+1,NOBJ
        IF( IDOBJ(I).EQ.IDOBJ(NID) )CALL RMOBJ(I,MINID,MINFID)
 20     CONTINUE
        KINDOBJ(NID)=IEOR(SYNOBYTE,KINDOBJ(NID))
      ELSE
        CALL RMOBJ(NID,MINID,MINFID)
      END IF
C
      RETURN
      END
C
      SUBROUTINE RMOBJ(NID,MINID,MINFID)
C
      IMPLICIT NONE
      INTEGER NID, MINID, MINFID
C
      INTEGER I, START, FINISH, DEPTH, LEVEL, NEWSIZE, K
#include "UDLIST.FOR"
C
C       MARK THIS OBJECT (BUT NOT WORLDS) ...
C
      IF(NID.GT.RWORLD)THEN
        KINDOBJ(NID)=IOR(KINDOBJ(NID),DELBYTE)
        IF(NID.LT.MINID)MINID=NID
        IF( (IDOBJ(ID).LT.MINFID) .AND. (ID.EQ.MASTSYN(ID)) )
     &    MINFID=IDOBJ(ID)
      END IF
C
C       AND ANYTHING IN ITS GROUP.
C       DO NOT MARK MASTER SYNONYMS IN GROUPS.
C
      IF(TYPOBJ(NID).EQ.GROUP)THEN
        CALL GROUPINFO(NID,START,FINISH,DEPTH,LEVEL,NEWSIZE)
        IF(START.EQ.1)START=0
        DO 10 I=START+1,FINISH
        K=TREE(I)
        IF(K.LE.GROUPEND)GOTO 10
        IF( BTEST(KINDOBJ(K),SYNOBIT).AND.(K.EQ.MASTSYN(K)) )GOTO 10
        KINDOBJ(K)=IOR(KINDOBJ(K),DELBYTE)
        IF(K.LT.MINID)MINID=K
 10     CONTINUE
      END IF
C
      RETURN
      END
C
      FUNCTION FRAMECHK(NID)
C
      IMPLICIT NONE
      INTEGER NID
      INTEGER I
C
#include "UDLIST.FOR"
C
      IF( (TYPOBJ(NID).EQ.FRAME).OR.(TYPOBJ(NID).EQ.ONEFRAME) )THEN
        DO 10 I=1,NOBJ
        IF( (I.NE.NID).AND.(IDOBJ(I).EQ.IDOBJ(NID)) )THEN
          FRAMECHK=.FALSE.
          RETURN
        END IF
 10     CONTINUE
        FRAMECHK=.TRUE.
      ELSE
        FRAMECHK=.FALSE.
      END IF
C
      RETURN
      END
