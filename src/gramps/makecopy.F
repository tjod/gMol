C *************************************************************
C This file contains source code for the gMol computer program
C  Copyright (C) 1981-2010 by TJ O'Donnell and
C  Copyright (C) 2005-2010 gNova, Inc.
C It is unlawful to modify or remove this copyright notice.
C See the accompanying LICENSE file for further information. 
C *************************************************************
	SUBROUTINE MAKECOPY(ARG,SWITCHES)
C
	IMPLICIT NONE
C
#include "UDLIST.FOR"
#include "ERRORS.FOR"
	INTEGER NEWSIZE
C
	CHARACTER ARG*(*)
	CHARACTER SWITCHES*(*)
	CHARACTER NAME*(NAMMAX)
	CHARACTER*12 PREFIX
	INTEGER AID, VPOINT, BID, PREFX, START, FINISH, DEPTH, LEVEL
	INTEGER NEWOBJ, I, NEWTREE
	INTEGER ASTART, BEND
C
C	 THIS ROUTINE MAKES COPIES OF OBJECTS
C	 IT CALLS OTHER ROUTINES DEPENDING ON WHETHER THE
C	 OBJECT TO COPY IS A ORDINARY, FRAMED OR GROUP OBJ.
C
C	 GET THE ARGS AND CHECK IF THE NAMES ARE OK
C
	POINT=1
	CALL NAMID(ARG,POINT,AID)
	IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
	IF(POINT.EQ.0)CALL TELLUSER(NONAME,*999)
	VPOINT=POINT
	CALL NAMEID(ARG,POINT,BID,NAME)
	IF(ERROR.EQ.0)ERROR=DUPNAM
	IF(ERROR.NE.OBJERR)THEN
	  POINT=VPOINT
	  CALL TELLUSER(ERROR,*999)
	END IF
	ERROR=0
	POINT=NPOINT
	CALL SMATCH(SWITCHES,'PREFIX',PREFIX,PREFX)
C
C
	GOTO (10,20,20,30)TYPOBJ(AID)+1
	CALL TELLUSER(NEVER,*999)
C
C	 MULTIPLE COPIES CAN BE MADE WITH ONE COPY
C	 COMMAND BY GIVING MULTIPLE NEW NAMES.
C	 CHECK SIZE OF THE OBJECT TO SEE IF IT CAN
C	 FIT IN REMAINING MEMORY.
C
 10   CONTINUE
	IF(SIZEOBJ(AID).GT.MAXUDL-UDFREE)
     *   CALL TELLUSER(TOOMUCH,*999)
	CALL OBJCOPY(AID,NAME)
	IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
	IF( BTEST(KINDOBJ(NOBJ),MENUBIT) )
     &    KINDOBJ(NOBJ)=IEOR(MENUBYTE,KINDOBJ(NOBJ))
	VPOINT=POINT
	CALL NAMEID(ARG,POINT,BID,NAME)
	IF(ERROR.EQ.NONAME)THEN
	  ERROR=0
	  RETURN
	ELSE
	  IF(ERROR.EQ.0)ERROR=DUPNAM
	  IF(ERROR.NE.OBJERR)THEN
	    POINT=VPOINT
	    CALL TELLUSER(ERROR,*999)
	  END IF
	  ERROR=0
	  POINT=NPOINT
	  GOTO 10
	END IF
C
 20   CONTINUE
	IF(FRAMESIZE.GT.MAXUDL-UDFREE)CALL TELLUSER(TOOMUCH,*999)
	CALL FRAMCOPY(AID,NAME)
	IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
	VPOINT=POINT
	CALL NAMEID(ARG,POINT,BID,NAME)
	IF(ERROR.EQ.NONAME)THEN
	  ERROR=0
	  RETURN
	ELSE
	  IF(ERROR.EQ.0)ERROR=DUPNAM
	  IF(ERROR.NE.OBJERR)THEN
	    POINT=VPOINT
	    CALL TELLUSER(ERROR,*999)
	  END IF
	  ERROR=0
	  POINT=NPOINT
	  GOTO 20
	END IF
	RETURN
C
C	 MAKING A GROUP COPY INVOLVES COPYING MANY INDIVIDUAL
C	 MEMBERS.  CHECK OUT THE GROUP WITH GROUPINFO AND
C	 SEE IF A DUPLICATE OF THE GROUP WILL FIT IN MEMORY.
C	 ALSO CALCULATE THE NUMBER OF NEW OBJS
C	 THAT WILL BE CREATED AND SEE IF IT IS MORE THAN THE
C	 MAXIMUM ALLOWED.  ALL THIS PRE-CHECKING IS DONE
C	 SO THAT GRCOPY SHOULD NEVER FAIL AND HAVE TO
C	 BACK OUT, DELETING MANY OBJECTS AND CLEANING UP 
C	 THE TREE....COULD BE MESSY.
C
 30   POINT=NPOINT
	CALL GROUPINFO(AID,START,FINISH,DEPTH,LEVEL,NEWSIZE)
	IF(NEWSIZE.GT.MAXUDL-UDFREE)CALL TELLUSER(TOOMUCH,*999)
	NEWOBJ=0
	DO 31 I=START,FINISH
	IF(TREE(I).GT.GROUPEND)NEWOBJ=NEWOBJ+1
 31   CONTINUE
	NEWTREE=FINISH-START+1
C
 32   CONTINUE
	IF(NEWTREE+TREEEND.GT.TREESIZE)CALL TELLUSER(TOOMANY,*999)
	IF(NEWOBJ+NOBJ.GT.MOBJ)CALL TELLUSER(TOOMANY,*999)
	IF(NEWOBJ+NIDS.GT.MOBJFR)CALL TELLUSER(TOOMANY,*999)
	IF(AID.GT.RWORLD)THEN
	  CALL OBJCOPY(AID,NAME)
	  CALL GRCOPY(AID,PREFIX)
	ELSE
	  ASTART=TREEEND+1
	  CALL GRCOPY(AID,PREFIX)
	  BEND=TREEEND
	  CALL GROUPMAKE(ASTART,BEND,NAME)
	END IF
	VPOINT=POINT
	CALL NAMEID(ARG,POINT,BID,NAME)
	IF(ERROR.EQ.NONAME)THEN
	  ERROR=0
	  RETURN
	ELSE
	  IF(ERROR.EQ.0)ERROR=DUPNAM
	  IF(ERROR.NE.OBJERR)THEN
	    POINT=VPOINT
	    CALL TELLUSER(ERROR,*999)
	  END IF
	  ERROR=0
	  POINT=NPOINT
	  GOTO 32
	END IF
C
 999  RETURN
	END
C
C
	SUBROUTINE OBJCOPY(AID,NAME)
C
	IMPLICIT NONE
	INTEGER AID
	CHARACTER NAME*(*)
#include "UDLIST.FOR"
	INTEGER I
C
C	 THIS ROUTINE COPIES AN ORDINARY OBJECT, OR
C	 INITIALIZES THE COPYING OF A GROUP BY CREATING
C	 A NEW OBJECT WITH THE SAME CONTENTS AS THE OLD ONE.
C	 OPEN AND CLOSE THE OBJECT, LETTING THESE ROUTINES
C	 KNOW WE'RE MAKING A NEW COPY, BUT FINALLY MARK THE
C	 OBJECT IN KINDOBJ LIKE THE ORIGINAL.
C
	CALL OPENOBJ(NAME,NEWCOPY)
	IF(ERROR.NE.0)RETURN
	DO 10 I=0,SIZEOBJ(AID)-1
	DLIST(UDFREE+I)=DLIST(LOCOBJ(AID)+I)
 10   CONTINUE
	UDFREE=UDFREE+SIZEOBJ(AID)
	LENGTH=SIZEOBJ(AID)
	CALL CLOSEOBJ(NEWCOPY)
C
C	 IF A COPY WAS MADE OF A SYNONYM, THE COPY IS
C	 NOT A SYNONYM; DON'T MARK IT AS SUCH
C
	KINDOBJ(NOBJ)=IAND( KINDOBJ(AID),NOT(SYNOBYTE) )
C
C	 TRANSCOPY COPIES TRANSFORMATION VALUES FROM
C	 THE OLD TO THE NEW OBJECT. THSHOULD BE OPTION IS
C	 SELECTABLE BY A SWITCH ON THE COPY COMMAND.
C
	CALL TRANSCOPY(AID,NOBJ)
C
	RETURN
	END
C
C
	SUBROUTINE FRAMCOPY(AID,NAME)
C
	IMPLICIT NONE
	INTEGER AID
	CHARACTER NAME*(*)
#include "UDLIST.FOR"
	INTEGER I
C
C	  THIS ROUTINE COPIES FRAMED OBJECTS IN ESSENTIALLY
C	  THE SAME WAY ORDINARY ONES ARE COPIED.  HOWEVER,
C	  INDIVIDUAL FRAMES ARE NOT COPIED SINCE ONLY
C	  POINTERS TO FRAMES CONTROL ACCESS TO FRAMES.
C
	CALL OPENOBJ(NAME,NEWCOPY)
	IF(ERROR.NE.0)RETURN
	DO 10 I=0,SIZEOBJ(AID)-1
	DLIST(UDFREE+I)=DLIST(LOCOBJ(AID)+I)
 10   CONTINUE
	LENGTH=SIZEOBJ(AID)
	UDFREE=UDFREE+SIZEOBJ(AID)
	CALL CLOSEOBJ(NEWCOPY)
	KINDOBJ(NOBJ)=IAND( KINDOBJ(AID),NOT(SYNOBYTE) )
C     FRMBASE(NOBJ)=FRMBASE(AID)
	FRMCNT(NOBJ)=FRMCNT(AID)
	OBJFRSIZ(IDOBJ(NOBJ))=SIZEOBJ(AID)
C
C	 AGAIN, SHOULD BE A SWITCH IN CASE TRANSFORMATION VALUES
C	 ARE NOT WANTED IN THE COPY.
C
	CALL TRANSCOPY(AID,NOBJ)
C
	RETURN
	END
C
C
	SUBROUTINE GRCOPY(AID,PREFIX)
C
	IMPLICIT NONE
	INTEGER AID
	CHARACTER PREFIX*(*)
#include "UDLIST.FOR"
	INTEGER GRPSIZE
	INTEGER BIGZ, LITTLEA, START, FINISH, DEPTH, LEVEL, I, K
C
	CHARACTER*(NAMMAX) NAME
	CHARACTER*1 BLANK
	EXTERNAL TRIM
C
	BIGZ=ICHAR('Z')
	LITTLEA=ICHAR('a')
	BLANK=' '
C
C
C	 THIS ROUTINE DUPLICATES EACH MEMBER OF A GROUP INTO
C	 A MEMBER OF THE NEWLY COPIED/SYNONYMED GROUP.  A NEW NAME
C	 MUST BE INVENTED (E.G. NEWNAME = A&OLDNAME) FOR
C	 EACH NEWLY CREATED GROUP MEMBER.
C
C	 THE MEMBER MAY BE COPIED OR SYNONYMED, DEPENDING ON
C	 TYPE OF THE ORIGINAL.  IF THE ORIGINAL WAS A SYNONYM,
C	 THEN THE DUPLICATE WILL ALSO BE, OTHERWISE THE DUPLICATE IS A
C	 FIND OUT ABOUT THE GROUP AND BUMP UP THE NEW_NAME_LETTER
C
C	 THE ROUTINE THAT CALL THIS ONE (MAKECOPY OR SYNONYM)
C	 SHOULD MAKE SURE THAT COPYING EACH MEMBER OF THE
C	 GROUP WILL NOT EXCEED SYSTEM LIMITS.  SEE MAKECOPY
C	 FOR AN EXAMPLE.
C
	CALL GROUPINFO(AID,START,FINISH,DEPTH,LEVEL,GRPSIZE)
	IF(PREFIX.EQ.BLANK)THEN
	  GRNUM=GRNUM+1
	  IF( (GRNUM.GT.BIGZ).AND.(GRNUM.LT.LITTLEA) )GRNUM=LITTLEA
	END IF
C
C	 NOW GO THROUGH THE WHOLE GROUP AND DUPLICATE EACH MEMBER
C	 INSERTING EACH NEW MEMBER INTO THE TREE.
C
	DO 10 I=START+1,FINISH
	K=TREE(I)
	IF(K.LE.GROUPEND)THEN
	  TREEEND=TREEEND+1
	TCHANGE=.TRUE.
	  TREE(TREEEND)=GROUPEND
	ELSE
	  IF(PREFIX.EQ.BLANK)THEN
CBUG!     NAME=CHAR(GRNUM) // '&' // NAMOBJ(K)
	    NAME(3:)=NAMOBJ(K)
	    NAME(2:2)='&'
	    NAME(1:1)=CHAR(GRNUM)
	  ELSE
	    NAME=PREFIX(:TRIM(PREFIX)) // NAMOBJ(K)
	  END IF
	  IF( BTEST(KINDOBJ(K),SYNOBIT) )THEN
	    CALL SYNOBJ(K,NAME)
	  ELSE
	    IF( (TYPOBJ(K).EQ.FRAME).OR.
     &	(TYPOBJ(K).EQ.ONEFRAME) )THEN
	      CALL FRAMCOPY(K,NAME)
	    ELSE
	      CALL OBJCOPY(K,NAME)
	    END IF
	  END IF
	END IF
 10   CONTINUE
C
	RETURN
	END
C
C
	SUBROUTINE TRANSCOPY(AID,BID)
C
	IMPLICIT NONE
	INTEGER AID, BID
C
#include "UDLIST.FOR"
	INTEGER  I, J
C
C	 THIS SUBROUTINE SIMPLY COPIES ARRAY ELEMENTS FROM
C	 AN ORIGINAL TO A DUPLICATE, FOR ALL THE ARRAYS THAT
C	 HOLD TRANSFORMATION VALUES, FUNCTION INFO ABOUT
C	 TRANSFORMATIONS, ETC.
C
	DO 10 I=1,MTFM
	CALL TFMCOPY(AID,BID,I)
 10   CONTINUE
	DEVUSE(SUMMARY,BID)=DEVUSE(SUMMARY,AID)
	FNUSE(SUMMARY,BID)=FNUSE(SUMMARY,AID)
C
C	 COPY OVER ARB AXIS MATRICES AND FIX MATRIX, TOO.
C
	DO 20 I=1,4
	DO 20 J=1,4
	ARBMAT(I,J,BID)=ARBMAT(I,J,AID)
	IARBMAT(I,J,BID)=IARBMAT(I,J,AID)
	FIXMAT(I,J,BID)=FIXMAT(I,J,AID)
 20   CONTINUE
C
	RETURN
	END
C
C
	SUBROUTINE TFMCOPY(AID,BID,TFMTYP)
C
	IMPLICIT NONE
	INTEGER AID, BID, TFMTYP
C
#include "UDLIST.FOR"
C
	TFMINC(TFMTYP,BID)=TFMINC(TFMTYP,AID)
	TFMVAL(TFMTYP,BID)=TFMVAL(TFMTYP,AID)
	DEVUSE(TFMTYP,BID)=DEVUSE(TFMTYP,AID)
	FNUSE(TFMTYP,BID) =FNUSE(TFMTYP,AID)
	LBOUND(TFMTYP,BID)=LBOUND(TFMTYP,AID)
	UBOUND(TFMTYP,BID)=UBOUND(TFMTYP,AID)
	TFMANG(TFMTYP,BID)=TFMANG(TFMTYP,AID)
	DFACT(TFMTYP,BID)=DFACT(TFMTYP,AID)
C
	RETURN
	END
