C *************************************************************
C This file contains source code for the gMol computer program
C  Copyright (C) 1981-2010 by TJ O'Donnell and
C  Copyright (C) 2005-2010 gNova, Inc.
C It is unlawful to modify or remove this copyright notice.
C See the accompanying LICENSE file for further information. 
C *************************************************************
      SUBROUTINE PUTTFM(NID,TFMTYP)
C
      IMPLICIT NONE
	INTEGER NID, TFMTYP
C
      REAL DELTA
	INTEGER  PUTFUNK, NDIM, NSKIP
C	Equivalence to COMMON ADDIT, etc. for convenience of
C	second name for these variables.
      LOGICAL ADDLOW,ADDUPP
      REAL LOWER, UPPER
      EQUIVALENCE (VAL,LOWER),(STEP,UPPER)
      EQUIVALENCE (ADDIT,ADDLOW),(ADDSTEP,ADDUPP)
#include "UDLIST.FOR"
#include "DEFVAL.FOR"
	Integer NCOORD
	Real X,Y,Z,W
	Real SCALE
C
C       THIS ROUTINE TAKES INFORMATION PARSED FROM A
C       TRANSFORMATION MODIFICATION COMMAND (E.G. ROTATE, TRANSLATE)
C       AND SETS UP THE TFMVAL, TFMINC, DEVUSE, FNUSE, DFACT,
C       AMPL, TFMANG, LBOUND, UBOUND AND BOUNDS ARRAYS SO
C       THAT THE UPDATE ROUTINES WILL HAVE THE INFO THEY
C       REQUIRE TO THE THE CORRECT TYPE OF TFM UPDATES.
C
C       FUNKY IS THE FUNCTION TYPE SPECIFIED.  MAY BE:
C       1) FNEGDEV: A NEGATIVE OF A DEVICE
C       2) FADDINC: A CONTINUOUS UPDATE NEEDS TO BE DONE EITHER
C             BECAUSE THE "C" WAS EXPLICITLY GIVEN BY THE
C             USER, OR BEACUSE CONT UPDATE IS IMPLIED BY
C             THE FLIMIT FUNCTION.
C       3) FLIMIT: A CONT UPDATE UP TO A LIMIT/DESTINATION BY
C            A) LINEAR INTERPOLATION OR
C            B) FSIN: SINUSOIDALLY VARYING STEPSIZE ADDITION
C       4) FBOUND: A TFM IS TO BE BOUNDED BY SOME VALUES
C       5) FBOUNCE: A BOUNDED TFM IS TO REBOUND AT THE BOUNDARY
C       6) FFACT: A DIVIDING FACTOR IS TO BE USED FOR A DEVICE.
C
      PUTFUNK=FUNKY
      IF(FUNKY.EQ.FNEGDEV)GOTO 99
C
 	SCALE=1./UNITS(TFMTYP)
C
      IF(FUNKY.EQ.0)THEN
        IF(.NOT.GOTVAL)GOTO 99
        IF(ADDIT)THEN
          TFMVAL(TFMTYP,NID)=
     &      TFMVAL(TFMTYP,NID)+VAL*SCALE
        ELSE
          TFMVAL(TFMTYP,NID)=VAL*SCALE
        END IF
C       CALL USHOW(NID,TFMTYP)
        GOTO 99
      END IF
C
      IF(FUNKY.EQ.FADDINC)THEN
        IF(.NOT.GOTVAL)GOTO 99
        IF(ADDIT)THEN
          TFMINC(TFMTYP,NID)=
     &      TFMINC(TFMTYP,NID)+VAL*SCALE
        ELSE
          TFMINC(TFMTYP,NID)=VAL*SCALE
        END IF
        GOTO 99
      END IF
C
      IF( BTEST(FUNKY,BLIMIT) )THEN
        TFMINC(TFMTYP,NID)=STEP
        IF(ADDIT)THEN
          BOUNDS(TFMTYP,NID)=TFMVAL(TFMTYP,NID) + VAL*SCALE
        ELSE
          IF(TFMVAL(TFMTYP,NID).EQ.VAL*SCALE)THEN
            PUTFUNK=0
            TFMINC(TFMTYP,NID)=0
            GOTO 99
          ELSE
            BOUNDS(TFMTYP,NID)=VAL*SCALE
          END IF
        END IF
        IF( BTEST(FUNKY,BSIN) )THEN
          DELTA = BOUNDS(TFMTYP,NID)
          AMPL(TFMTYP,NID) = ( DELTA - TFMVAL(TFMTYP,NID) )/2
          TFMANG(TFMTYP,NID)=0.0
        END IF
        GOTO 99
      END IF
C
      IF( BTEST(FUNKY,BBOUNDED) )THEN
        IF(ADDLOW)THEN
          LBOUND(TFMTYP,NID)=TFMVAL(TFMTYP,NID) + LOWER*SCALE
        ELSE
          LBOUND(TFMTYP,NID)=LOWER*SCALE
        END IF
        IF(ADDUPP)THEN
          UBOUND(TFMTYP,NID)=TFMVAL(TFMTYP,NID) + UPPER*SCALE
        ELSE
          UBOUND(TFMTYP,NID)=UPPER*SCALE
        END IF
        GOTO 99
      END IF
C
C     VAL  is object ID to follow.
C     NDIM is the dimensionality of that obj (assume 3 for now)
C     ADDINC is the number of data points to skip per update.
C     These three values are packed into TFMINC (ugly!)
C
      IF( BTEST(FUNKY,BOBJ) )THEN
        LBOUND(TFMTYP,NID)=0
        UBOUND(TFMTYP,NID)=0
      NDIM=3
      NSKIP=STEP
        TFMINC(TFMTYP,NID)=(NSKIP*10 + NDIM)*MOBJ + VAL
        GOTO 99
      END IF
C
      IF( FUNKY.EQ.FCOORD )Then
	NCOORD=VAL
	If(NCOORD.LT.0)Then
		X=-UCOORD(1,ABS(NCOORD))
		Y=-UCOORD(2,ABS(NCOORD))
		Z=-UCOORD(3,ABS(NCOORD))
	Else
		X= UCOORD(1,NCOORD)
		Y= UCOORD(2,NCOORD)
		Z= UCOORD(3,NCOORD)
	End If
	W=UCOORD(4,ABS(NCOORD))
        IF(TFMTYP.EQ.UTRANX  .OR. TFMTYP.EQ.UROTXX .OR.
     &     TFMTYP.EQ.UATRANX .OR. TFMTYP.EQ.UAROTX .OR.
     &     TFMTYP.EQ.UASCALX .OR. TFMTYP.EQ.USCALEX .OR.
     &     TFMTYP.EQ.UCHUE   .OR. TFMTYP.EQ.UITRNSP .OR.
     &     TFMTYP.EQ.UFRAME ) TFMVAL(TFMTYP,NID)=X
        IF(TFMTYP.EQ.UTRANY  .OR. TFMTYP.EQ.UROTYY .OR.
     &     TFMTYP.EQ.UATRANY .OR. TFMTYP.EQ.UAROTY .OR.
     &     TFMTYP.EQ.UASCALY .OR. TFMTYP.EQ.USCALEY .OR.
     &     TFMTYP.EQ.UCSAT   .OR. TFMTYP.EQ.UIAMBI .OR.
     &	   TFMTYP.EQ.UFRAMI )TFMVAL(TFMTYP,NID)=Y
        IF(TFMTYP.EQ.UTRANZ  .OR. TFMTYP.EQ.UROTZZ .OR.
     &     TFMTYP.EQ.UATRANZ .OR. TFMTYP.EQ.UAROTZ .OR.
     &     TFMTYP.EQ.UASCALZ .OR. TFMTYP.EQ.USCALEZ .OR.
     &     TFMTYP.EQ.UCVAL   .OR. TFMTYP.EQ.UISPEC)TFMVAL(TFMTYP,NID)=Z
        IF(TFMTYP.EQ.UTRANW  .OR. TFMTYP.EQ.UATRANW .OR.
     &     TFMTYP.EQ.UASCALW .OR. TFMTYP.EQ.USCALEW)TFMVAL(TFMTYP,NID)=W
	PUTFUNK=0
      End If
C
 99   DEVUSE(TFMTYP,NID)=DEV
      FNUSE(TFMTYP,NID)=PUTFUNK
      DFACT(TFMTYP,NID)=FACTOR
      if (DEV. NE. 0) call setdevval(DEV,TFMVAL(TFMTYP,NID),1)
C
      DCHANGE=.TRUE.
      RETURN
      END
