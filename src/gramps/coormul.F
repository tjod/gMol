C *************************************************************
C This file contains source code for the gMol computer program
C  Copyright (C) 1981-2010 by TJ O'Donnell and
C  Copyright (C) 2005-2010 gNova, Inc.
C It is unlawful to modify or remove this copyright notice.
C See the accompanying LICENSE file for further information. 
C *************************************************************
      SUBROUTINE COORMUL(KNID,FID)
C
      IMPLICIT NONE
#include "UDLIST.FOR"
#include "TFMMAT.FOR"
#include "ERRORS.FOR"
C
      INTEGER I,LASTI
      REAL TFMRAD
      INTEGER KNID, FID, NDIM, TMPLINE, CHLEN
      INTEGER NID,  N, LDM1, LDM2, LDMTMP, J, K
	REAL HUE, SAT, VALU
	Real RDM1, RDM2
C
C       THIS ROUTINE MULTIPLIES THE COORDS OF AN OBJECT BY
C       THE CURRENT TFM MATRIX.  KNID IS THE OBJECT NUMBER.
C       FID IS TAKEN TO BE THE OBJFR ID.
C       THIS MAKES FRAMES WORK.
C
C       GROUPS OR WORLDS HAVE NO COORDS!
C       BUT THE WORLD SHOULD HAVE ITS COLOR, ETC. WORDS COPIED
C       INTO USLIST.
C
      IF(TYPOBJ(KNID).EQ.GROUP)RETURN
C
      USSIZE=1
      LENGTH=0
      I=OBJFRLOC(FID)
      LASTI=I+OBJFRSIZ(FID)
      NDIM=3
      BASEZ=0
      BASEW=0
C
C       WRITE OUT THE OBJ COLOR AND INTENSITY.
C       COLOR MUST COME FIRST!  SEE DUMPTDL IN DUMPBUFF.FOR
C       IF A SYNONYM, REFER TO COLOR, INTENSITY OF MASTER.
C
      NID=MASTSYN(KNID)
      CALL HUESAT(NID,HUE,SAT,VALU)
C
      CALL USCHECK(USSIZE+5,*999)
      USLIST(USSIZE)=0
      USLIST(USSIZE+1)=4
      USLIST(USSIZE+2)=1
      USLIST(USSIZE+3)=HUE
      USLIST(USSIZE+4)=SAT
      USLIST(USSIZE+5)=VALU
      USSIZE=USSIZE+6
C
C	All output is 3-d!
C
       CALL USCHECK(USSIZE+2,*999)
       USLIST(USSIZE)=0
       USLIST(USSIZE+1)=0
       USLIST(USSIZE+2)=1
       USSIZE=USSIZE+3
C
 20   IF(I.GE.LASTI)RETURN
C
C       THE FIRST LINE MUST BE A INFO LINE
C
C       CHECK OUT THE POSSIBILITES
C            N>0  SPECIFIES A LINE TO BE DRAWN OF N POINTS
C            N=0  SPECIFIES A SPECIAL FUNCTION
C            N<0  END OF THIS OBJECT, BUT FILE HAS MORE OBJECTS (FRAMES)
C
      N=DLIST(I)
      LDM1=DLIST(I+1)
      LDM2=DLIST(I+2)
      RDM1=DLIST(I+1)
      RDM2=DLIST(I+2)
      I=I+3
      IF(N)999,40,30
C
C       PROCESS THE N POINTS THAT FOLLOW.
C
 30   CONTINUE
      CALL USCHECK(USSIZE+3+4*N,*999)
      USLIST(USSIZE)=N
      USLIST(USSIZE+1)=LDM1
      LDMTMP=ABS(LDM2)
      IF(LDMTMP.EQ.4)THEN
        USLIST(USSIZE+2)=SIGN(3,LDM2)
      ELSE IF(LDMTMP.EQ.5)THEN
        USLIST(USSIZE+2)=SIGN(1,LDM2)
      ELSE IF(LDMTMP.EQ.6)THEN
        USLIST(USSIZE+2)=SIGN(2,LDM2)
      ELSE
        USLIST(USSIZE+2)=LDM2
      END IF
C     IF(LDM1.EQ.5)THEN
C       USLIST(USSIZE+2)=TFMRAD(LDM2)
C     ELSE
C       USLIST(USSIZE+2)=LDM2
C     END IF
      USSIZE=USSIZE+3
C
C       FOR EVERY COORDINATE IN THIS LINE, GET THE TRANSFORMED
C       COORD AND STORE IT IN THE BUFFER USLIST.
C
      IF(LDM1.EQ.8)THEN
        DO 35 J=0,N*3-1
        USLIST(USSIZE+J)=DLIST(J+I)
 35     CONTINUE
        I=I+3*N
        USSIZE=USSIZE+3*N
      ELSE
        CALL TFMCOOR(N,LDM1,LDM2,NDIM,I)
      END IF
      GOTO 20
C
C       SPECIAL FUNCTION REQUIRES LOOKING AT LDM1 TO
C       DETERMINE WHICH SPECIAL FUNCTION
C
 40   CONTINUE
      CALL USCHECK(USSIZE+3,*999)
      USLIST(USSIZE)=N
      USLIST(USSIZE+1)=RDM1
      USLIST(USSIZE+2)=RDM2
      USSIZE=USSIZE+3
      GOTO (100,200,300,400,500,600,700,800,400,900) LDM1 + 1
C
C       IF WE GET HERE, AN ILLEGAL SPECIAL FUNCTION VALUE WAS SUPPLIED
C
 50   ERROR=BADUDL
      IF(FULLERR)WRITE(TMPLINE,'(A,2I4,A,I8)')
     &   'OBJECT ', KNID, NID,' AT ', I
      RETURN
C
C       SET THE BASE REGISTER FOR SUBSEQUENT DRAWS
C
 100  CONTINUE
C
C       THE LDM2 IS !0, THEN BASEW = LDM2
C       OTHERWISE READ THE BASES IN ON THE NEXT LINE
C
      IF(LDM2.NE.0)THEN
         BASEW=LDM2
      ELSE
         BASEX=DLIST(I)
         BASEY=DLIST(I+1)
         BASEZ=DLIST(I+2)
         BASEW=DLIST(I+3)
         I=I+4
      END IF
C	Kludge to avoid output (USLIST) being scaled twice.
      USSIZE=USSIZE-3
C     CALL USCHECK(USSIZE+4,*999)
C     USLIST(USSIZE)=BASEX
C     USLIST(USSIZE+1)=BASEY
C     USLIST(USSIZE+2)=BASEZ
C     USLIST(USSIZE+3)=BASEW
C     USSIZE=USSIZE+4
      GOTO 20
C
C	Cylinder radius
C       INFO ALREADY STORED AS N,LDM1,LDM2
C
 200  CONTINUE
      USLIST(USSIZE-1)=TFMRAD(RDM2)
      GOTO 20
C
C       MAKE THE FOLLOWING LINES DASHED.  LDM2 SPECIFIES
C       THE 16 POSSIBLE DASHED OPTIONS AVAILABLE.
C       THE "TENS" DIGIT MEANS CONTINUOUS TEXTURE.
C       SEE THE E&S SUPPLIED LDASH SUBROUTINE FOR MORE DETAILS.
C
C       NO CHECKING IS DONE HERE FOR ILLEGAL VALUES
C
 300  CONTINUE
      GOTO 20
C
C       TEXT STRING TO BE DISPLAYED.
C       REQUIRES THREE ADDITIONAL ITEMS:
C        1) THE COORDINATES OF THE TEXT.
C        1a)X AND Y SCALEING FOR SOFTTEXT AND FONT TYPE
C        2) THE LENGTH OF THE TEXT STRING.
C        3) THE TEXT STRING ITSELF, AS ASCII INTEGER CODE - NUMBER
C           WORDS AS SPECIFIED BY LENGTH (YES, I KNOW I'M WASTING
C           A BYTE BY STORING ONE CHARACTER PER WORD, BUT IT'S FOR
C           TRANSPORTABILITY'S SAKE - I'VE LEARNED THE HARD WAY).
C
 400  CONTINUE
C       1)
      CALL TFMCOOR(1,LDM1,4,4,I)
	USLIST(USSIZE)=1.0
	USSIZE=USSIZE+1
C
C       1a)
      CALL USCHECK(USSIZE+6,*999)
      DO 401 K=1,6
      USLIST(USSIZE+K-1)=DLIST(I+K-1)
 401  CONTINUE
      I=I+6
      USSIZE=USSIZE+6
C
C       2)
      CHLEN=DLIST(I)
      CALL USCHECK(USSIZE+1+CHLEN,*999)
      USLIST(USSIZE)=CHLEN
      USSIZE=USSIZE+1
      I=I+1
C
C       3)
      DO 404 K=0,CHLEN-1
      USLIST(USSIZE+K)=DLIST(I+K)
 404  CONTINUE
      USSIZE=USSIZE+CHLEN
      I=I+CHLEN
C
      GOTO 20
C
C       SET THE COLOR FOR THIS PICTURE.
C       READ THE NEXT WORD WHICH HAS HUE, SATURATION and VALUE.
C
 500  CONTINUE
      CALL USCHECK(USSIZE+3,*999)
      USLIST(USSIZE)=  DLIST(I)
      USLIST(USSIZE+1)=DLIST(I+1)
      USLIST(USSIZE+2)=DLIST(I+2)
      USSIZE=USSIZE+3
      I=I+3
      GOTO 20
C
C       SET THE LSPEED GIVEN IN LDM2.
C
 600  CONTINUE
      GOTO 20
C
C       CHANGE DEFAULT DIMENSION
C
 700  CONTINUE
        IF( (LDM2.GE.2).AND.(LDM2.LE.4) )THEN
        NDIM=LDM2
      ELSE
        GOTO 50
      END IF
C	Kludge to avoid output (USLIST) being non-3d
      USSIZE=USSIZE-3
      GOTO 20
C
C       SET THE INTENSITY, FRONT AND SIZE.
C
 800  CONTINUE
      CALL USCHECK(USSIZE+2,*999)
      USLIST(USSIZE)=DLIST(I)
      USLIST(USSIZE+1)=DLIST(I+1)
      USSIZE=USSIZE+2
      I=I+2
      GOTO 20
C
C	Sphere radius
C       INFO ALREADY STORED AS N,LDM1,LDM2
C
 900  CONTINUE
      USLIST(USSIZE-1)=TFMRAD(RDM2)
      GOTO 20
C
 999  RETURN
      END
C
      SUBROUTINE TFMCOOR(N,LDM1,LDM2,NDIM,I)
C
      IMPLICIT NONE
#include "UDLIST.FOR"
#include "TFMMAT.FOR"
C
      INTEGER I,LASTI
      INTEGER N, LDM1, LDM2, NDIM, JDIM, NN, L, J, K
      REAL TFMRAD
C
C       THIS ROUTINE TRANSFORMS OLD COORDS FROM DLIST
C       BY APPLYING THE CURRENT TFM MATRIX TO PRODUCE
C       NEW COORDS IN USLIST.
C       IT OPERATES ON N COORDS, OF NDIM DIMENSIONALITY.
C       I IS THE POINTER INTO DLIST AND IS UPDATED HERE.
C       USSIZE IS THE POINTER INTO USLIST, AND IS UPDATED
C       HERE - IT IS IN COMMON.
C
      LOGICAL OFLOW
      INTEGER NORMLS
      REAL TCOMP
      REAL NEW(4),OLD(4),NEWMAX
      REAL NEWX,NEWY,NEWZ,NEWW,OLDX,OLDY,OLDZ,OLDW
      EQUIVALENCE (NEWX,NEW(1)),(OLDX,OLD(1))
      EQUIVALENCE (NEWY,NEW(2)),(OLDY,OLD(2))
      EQUIVALENCE (NEWZ,NEW(3)),(OLDZ,OLD(3))
      EQUIVALENCE (NEWW,NEW(4)),(OLDW,OLD(4))
C
      IF(ABS(LDM2).NE.3 .AND. ABS(LDM2).NE.4)THEN
	NORMLS=1
      ELSE
	NORMLS=0
      END IF
      IF( (LDM1.EQ.6 .OR. LDM1.EQ.7 .OR. LDM1.EQ.9 .OR. LDM1.EQ.10).AND.
     &		NORMLS.EQ.1 )THEN
        JDIM=3
	If(LDM1.EQ.6 .OR. LDM1.EQ.7)Then
	        NN=N*2
	Else
		NN=N*3
	End If
      ELSE
	If(LDM1.EQ.9 .OR. LDM1.EQ.10)Then
        	NN=N*2
	Else
        	NN=N
	End IF
        JDIM=NDIM
	NORMLS=0
      END IF
C
      DO 400 L=1,NN
      If((LDM1.EQ.9 .OR. LDM1.EQ.10) .AND. MOD(L,3).EQ.0)Then
		Do j=0,2
		USLIST(USSIZE+j)=DLIST(I+j)
		End Do
		I=I+3
		USSIZE=USSIZE+3
		Goto 400
      Else
	      NORMLS=-NORMLS
      End If
C
      OLDX=DLIST(I)
      OLDY=DLIST(I+1)
      IF(JDIM.GE.3)THEN
        OLDZ=DLIST(I+2)
      ELSE
        OLDZ=BASEZ
      END IF
      IF(JDIM.EQ.4)THEN
        IF(LDM1.EQ.5)THEN
          OLDW=0. 
        ELSE
          OLDW=DLIST(I+3)
        END IF
      ELSE
        OLDW=BASEW
      END IF
      I=I+JDIM
C
      IF(OLDW.EQ.0.)THEN
        IF(ABS(LDM2).GE.4)THEN
          OLDW=32767.
        ELSE
          OLDW=1.
        END IF
      END IF
C
C       HERE'S THE HEART OF IT, FOLKS...THE MATRIX MULTIPLY.
C
      DO 200 J=1,4
      NEW(J)=0.0
C
        DO 100 K=1,4
        NEW(J)=NEW(J) + OLD(K)*TFMMTX(K,J,CURRENT)
 100    CONTINUE
 200    CONTINUE
C
C       NORMALIZE THE NEW COORDS. AND STORE IN OUTPUT BUFFER.
C	SUBTRACT OUT TRANSLATION COMPONENT FOR NORMAL VECTORS.
C
      DO 300 J=1,3
	IF(NORMLS.EQ.1)THEN
	  TCOMP=TFMMTX(4,J,CURRENT)/TFMMTX(4,4,CURRENT)
          USLIST(USSIZE)=NEW(J)/NEW(4) - TCOMP
	ELSE
          USLIST(USSIZE)=NEW(J)/NEW(4)
	END IF
	USSIZE=USSIZE+1
 300  CONTINUE
C
C	Sphere special case.
C
      IF(LDM1.EQ.5)THEN
        If (LDM2.EQ.0) Then
          USLIST(USSIZE)=TFMRAD(DLIST(I)/OLDW)
          I=I+1
          USSIZE=USSIZE+1
        End If
      END IF
 400  CONTINUE
C
      RETURN
      END
C
      REAL FUNCTION TFMRAD(X)
C
      IMPLICIT NONE
      REAL X
#include "UDLIST.FOR"
#include "TFMMAT.FOR"
C
C       THIS ROUTINE TRANSFORMS A SINGLE NUMBER X
C       BY APPLYING THE CURRENT TFM MATRIX TO PRODUCE
C       A NEW NUMBER.  THIS ROUTINE ONLY
C       APPLIES THE SCALE FACTOR PORTION OF THE CURRENT
C       TFM MATRIX!
C
      REAL XS,YS,ZS,WS
C
      WS=TFMMTX(4,4,CURRENT)
      XS=TFMMTX(1,1,CURRENT)/WS
      YS=TFMMTX(1,2,CURRENT)/WS
      ZS=TFMMTX(1,3,CURRENT)/WS
C
      TFMRAD=X * SQRT(XS*XS + YS*YS + ZS*ZS)
C
      RETURN
      END
C
      SUBROUTINE USCHECK(N,*)
C
      IMPLICIT NONE
#include "UDLIST.FOR"
#include "ERRORS.FOR"
      INTEGER N
C
      IF (N.GT.BUFLEN)THEN
        CALL TELLUSER(PSMEMFULL)
        ERROR=PSMEMFULL
        RETURN 1
      ELSE
        RETURN
      END IF
C
      END
C
      SUBROUTINE HUESAT(NID,HUE,SAT,VALU)
C
      IMPLICIT NONE
#include "UDLIST.FOR"
      INTEGER NID
      REAL HUE, SAT, VALU
C
      HUE=ABS(TFMVAL(UCHUE,NID))
      SAT=ABS(TFMVAL(UCSAT,NID))
      VALU=ABS(TFMVAL(UCVAL,NID))
      RETURN
      END
