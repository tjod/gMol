C *************************************************************
C This file contains source code for the gMol computer program
C  Copyright (C) 1981-2010 by TJ O'Donnell and
C  Copyright (C) 2005-2010 gNova, Inc.
C It is unlawful to modify or remove this copyright notice.
C See the accompanying LICENSE file for further information. 
C *************************************************************
      SUBROUTINE SET(ARG, SWITCHES)
C
      IMPLICIT NONE
      CHARACTER ARG*(*)
      Character SWITCHES*(*)
C
#include "UDLIST.FOR"
#include "ERRORS.FOR"
#include "FILES.FOR"
C#include "DEVICES.FOR"
#include "TFMMAT.FOR"
#include "DEFVAL.FOR"
#include "G0COMMON.FOR"
C
      CHARACTER*1 BLANK
      CHARACTER*3 EXT
      CHARACTER*60 OUTTYPE
      CHARACTER*60 OUTTEMP
      CHARACTER*100 SAVDIR
      CHARACTER*5 RTMP,COLBK
      CHARACTER*6 KEYTYP
      CHARACTER*20 ATSIZE
      CHARACTER*20 ARGTMP
      CHARACTER*80 FFONT
      REAL ATIME
      Real SCALE
      CHARACTER*6 APPEND
      INTEGER CVAL, IVAL
      INTEGER SOURCE, DESTIN
      Real HUE,SAT,VALU
      Integer IHUE,ISAT,IVALU
      INTEGER XORI, YORI, XSIZ, YSIZ
      REAL RVAL, GVAL, BVAL
      REAL LORES, HIRES
      INTEGER LON, LOREP, HIN, HIREP
      Logical BORDER
      Integer SCOPE
      INTEGER NVAL, ZERO, MINUS5, MINUS2, ONE, VPOINT, WHEND, I
      INTEGER OTEND
      LOGICAL DUMMY
      INTEGER TTSIZE, XTSIZE
      Integer firstframe, numframes
      EXTERNAL TRIM
      Integer GETDIR, CD
      Logical gotsw, LWORK(WORKSIZE)
      Equivalence (WORK,LWORK)
C
      INTEGER NTYPES
      PARAMETER (NTYPES=72)
      CHARACTER*15 TYPES(NTYPES),WHICH
      SAVE TYPES
      DATA TYPES /'STEREO','NOSTEREO','VERIFY','NOVERIFY',
     &    'DEFAULT','SENSITIVITY','WATCH','NOWATCH',
     &    'COLLECT','NOCOLLECT','FILMPAUSE','FULLERROR',
     &    'NOFULLERROR',
     &    'TEXTSIZE','AUTOCLEAR','NOAUTOCLEAR','OVERLAP',
     &    'NOOVERLAP','DISPLAY','NODISPLAY','SPILL',
     &    'MAXDEPTH','FRAMECOUNT','ECHO','NOECHO',
     &    'LOWERCASE','NOLOWERCASE','REPORT','NOREPORT',
     &    'CURSOR','NOCURSOR','DOUBLEBUFFER','SINGLEBUFFER',
     &    'PENSTOP','NOPENSTOP','RIGHTHANDED','LEFTHANDED',
     &    'OUTPUT','NOOUTPUT','BACKGROUND','SOFTTEXT','BITMAPTEXT',
     &    'LIBRARY','HIDESURF','NOHIDESURF','FLAT','GOURAUD',
     &    'SMOOTHLINE','NOSMOOTHLINE','NOBACKFACE','BACKFACE',
     &    'RGBMODE','COLORMAPMODE','SPECULARINT','DIFFUSEINT',
     &    'AMBIENTINT','EMISSIVITY','SHININESS','BACKRGB','BACKHSV',
     &    'ALPHABLEND','NOALPHABLEND','CYLINDERS', 'TWIST','SPHERES',
     &    'COMMANDOUT','KEYS','OLDUNITS','NEWUNITS',
     &    'MENU', 'NOMENU', 'NORMALIZATION'/
C
      DATA MINUS5/-5/,ZERO/0/
      DATA MINUS2/-2/,ONE/1/
      DATA BLANK/' '/
      MINUS5=-5
      ZERO=0
      MINUS2=-2
      ONE=1
      BLANK=' '
C
C   THIS ROUTINE WILL SET VALUES OR FLAGS OF VARIOUS
C   SYSTEM VARIABLES.  THE TABLE ABOVE CONTAINS THE
C   NAMES OF THE VARIABLES WHICH CAN BE MODIFIED.
C
C   GET THE NAME OF THE VARIABLE TO MODIFY
C
      POINT=1
      VPOINT=1
      CALL GETSTR(ARG,POINT,WHICH)
      CALL UPCASE(WHICH)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      WHEND=TRIM(WHICH)
      IF(WHEND.EQ.0)THEN
        POINT=0
        CALL TELLUSER(INCOMP,*999)
      END IF
C
C   CHECK OUT THE TABLE OF NAMES FOR A MATCH
C   AND GO TO THE CORRECT SPOT
C
      DO 2 I=1,NTYPES
      IF(INDEX(TYPES(I),WHICH(:WHEND)).EQ.1)THEN
        GOTO (10,15,20,25,30,40,50,55,60,65,70,80,85,90,
     &     100,105,110,115,120,125,130,140,150,160,165,
     &     170,175,180,185,190,195,200,205,210,215,220,225,
     &     230,235,240,250,255,260,270,275,280,285,290,295,
     &     300,305,310,315,320,330,340,350,360,370,380,390,395,
     &     400,410,420,430,440,450,460,470,480,490)I
      END IF
 2    CONTINUE
C
C  NO VALID KEYWORD WAS FOUND.  ERROR!
C
      POINT=VPOINT
      CALL TELLUSER(AXISERR,*999)
C
C   IF STEREO IS TO BE TURNED ON, THEN
C   COPY LWORLD ATTRIBUTES TO RWORLD (RIGHTON).
C
 10   CONTINUE
      IF(STEREO.NE.NOSTEREO)RETURN
C
      IF(POINT.EQ.0)THEN
        STEREO = LRSTEREO
      ELSE
        CALL GETSTR(ARG,POINT,ARGTMP)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      IF(ARGTMP(1:1).EQ.'Z')THEN
        STEREO=ZSTEREO
      ELSE IF(ARGTMP(1:1).EQ.'UD')THEN
        STEREO=UDSTEREO
C      ELSE IF(ARGTMP(1:1).EQ.'D')THEN
C        STEREO=UDSTEREO
      ELSE IF(ARGTMP(1:1).EQ.'LR')THEN
        STEREO=LRSTEREO
C      ELSE IF(ARGTMP(1:1).EQ.'L')THEN
C        STEREO=LRSTEREO
C      ELSE IF(ARGTMP(1:1).EQ.'R')THEN
C        STEREO=LRSTEREO
      ELSE IF(ARGTMP(1:1).EQ.'F')THEN
        STEREO=FSTEREO
      ELSE IF(ARGTMP(1:2).EQ.'RG')THEN
        STEREO=RGSTEREO
      ELSE
        STEREO=LRSTEREO
      END IF
      END IF
C
      CALL G0ASPECT
      CALL RIGHTON
      DCHANGE=.TRUE.
      RETURN
C
C   TURN STEREO OFF BY RESETTING TRANSLATION, MOVE AND
C   SETTING STEREO FLAG FALSE, DEACTIVIATING RWORLD.
C
 15   CONTINUE
      IF(STEREO.EQ.NOSTEREO)RETURN
C
      CALL RIGHTOFF
      STEREO=NOSTEREO
      CALL G0ASPECT
      DCHANGE=.TRUE.
      RETURN
C
C   SET THE VERIFY FLAG SO THAT COMMANDS FROM .GIN FILES
C   ARE ECHOED AT THE TERMINAL WHEN INTERPRETED.
C
 20   VERIFY=.TRUE.
      SKIPCOLL=.TRUE.
      IF(POINT.NE.0)THEN
        CALL GETVLU(ARG,POINT,IVAL,ADDIT)
        IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
        IF(IVAL.GT.0)THEN
          VERLVL=IVAL
        ELSE
          VERLVL=0
        END IF
      ELSE
        VERLVL=0
      END IF
      RETURN
C
C   SET VERIFY FALSE
C
 25   VERIFY=.FALSE.
      SKIPCOLL=.TRUE.
      VERLVL=0
      RETURN
C
C   CHANGE THE DEFAULT DIRECTORY.  
C   CHECK WITH VMS ABOUT THE LEGALITY OF THE DIRECTORY.
C
 30   CONTINUE
      If(SWITCHES.EQ.BLANK)Then
        IF(POINT.EQ.0)THEN
          DEFDIR=BLANK
        ELSE
          VPOINT=POINT
          CALL GETSTR(ARG,POINT,SAVDIR)
          IVAL=GETDIR(SAVDIR,DEFDIR,.TRUE.)
C          DEFDIR=SAVDIR
        END IF
C#ifdef QT
C        if (cd(defdir(:TRIM(defdir))) .eq. 0) Then
C          point = vpoint
C          call telluser1(BADDIR)
C        End If
C#endif
C
C Set default units
      Else
        If(wreset(switches))Then
            CALL GETVLX(ARG,POINT,VAL,ADDIT)
          gotsw=.false.
          Do 31 i=1,MTFM
          SCALE=1./UNITS(i)
          If(LWORK(i))Then
            gotsw=.true.
            DEFVAL(i)=VAL*SCALE
          End If
 31   Continue
          Do 32 i=1,WTFM
          SCALE=1./WUNITS(i)
          If(LWORK(MTFM+i))Then
            gotsw=.true.
            DEFWLD(i)=VAL*SCALE
          End If
 32   Continue
        Else
          gotsw=.false.
        End If
        If(.not.gotsw)Call Telluser1(BADSWITCH)
      End If
      RETURN
C
C   SET THE DIVIDEND FOR DEVICE INTERRUPT VALUES
C
 40   CALL GETSTR(ARG,POINT,RTMP)
      RVAL=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      IF(RVAL.EQ.0)RVAL=2
      ADSENS=RVAL
      RETURN
C
C   SET THE WATCH FLAG SO THAT THE EFFECTS ON THE DISPLAY OF
C   .GIN FILES IS SEEN AFTER THE INTERPRETATION OF EACH
C   COMMAND LINE, RATHER THAN ONLY AFTER THE ENTIRE FILE.
C
 50   WATCH=.TRUE.
      RETURN
C
C   TURN WATCHING OFF
C
 55   WATCH=.FALSE.
      RETURN
C
C   SET COLLECT MODE, PARSE THE FILENAME TO BE
C   COLLECTED INTO, AND OPEN THE FILE.
C
 60   IF(COLLECT)CALL TELLUSER(ONECOLL,*999)
      IF(POINT.NE.0)THEN
        VPOINT=POINT
        CALL GETSTR(ARG,POINT,COLLFILE)
        APPEND=' '
      ELSE
        IF(COLLFILE.EQ.BLANK)CALL TELLUSER(NONAME,*999)
        APPEND='APPEND'
      END IF
      DEFEXT='gin'
      ERROR=OPENFILE(COLLFILE,CFILE,.TRUE.,APPEND)
      IF(ERROR.NE.0)THEN
        POINT=VPOINT
        CALL TELLUSER(ERROR,*999)
      ELSE
        COLLECT=.TRUE.
        SKIPCOLL=.TRUE.
      END IF
      RETURN
C
C   CLOSE THE COLLECT FILE, AND FLAG COLLECT OFF
C
 65   CLOSE (UNIT=CFILE)
      COLLECT=.FALSE.
      RETURN
C
C   SET THE INTERVAL FOR TIME DELAYS USED BETWEEN ADVANCES
C   SEE THE ADVANCE COMMAND.
C
 70   CONTINUE
      IF(POINT.EQ.0)THEN
      FPAUSE=1.
      ELSE
        VPOINT=POINT
        CALL GETSTR(ARG,POINT,RTMP)
        ATIME=A2F(RTMP,ERROR)
        IF(ERROR.NE.0)GO TO 71
        IF( (ATIME.LT.0).OR.(ATIME.GT.100.) )GOTO 71
      FPAUSE=ATIME
      END IF
      IF(FPAUSE.EQ.0.)THEN
        FILMPAUSE=.FALSE.
      ELSE
        FILMPAUSE=.TRUE.
      END IF
      RETURN
C
C   ERROR EXIT POINT FOR SET FILMPAUSE
C
 71   POINT=VPOINT
      CALL TELLUSER(BADTIME,*999)
C
C   FLAG THAT FULL ERROR REPORTING IS ON.  
C   CAUSES TELLUSER TO REPORT MORE FULLY ON ERRORS.
C
 80   FULLERR= .TRUE.
      RETURN
C
 85   FULLERR = .FALSE.
      RETURN
c
C   CHANGE THE DEFAULT TEXT SIZE FOR THE TEXT COMMAND
C
 90   CONTINUE
      VPOINT=POINT
      CALL GETVLU(ARG,POINT,IVAL,DUMMY)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
C  IF((IVAL.LE.0).OR.(IVAL.GT.8))THEN
      IF(IVAL.LE.0)THEN
        POINT=VPOINT
        CALL TELLUSER(BADVALUE,*999)
      END IF
      CALL G0DTSIZE(IVAL)
      Call G0DFONT(0)
      DCHANGE=.TRUE.
      RETURN
C
C   ALLOW DISPLAY OUTPUT TO BE AUTOCLEARED - see advance
C
 100  AUTOCLEAR=.TRUE.
C     DCHANGE=.TRUE.
      RETURN
C
C   FORCE UDL TO BE NOT AUTOCLEAR - SEE DISPLAY
C
 105  AUTOCLEAR=.FALSE.
C     DCHANGE=.TRUE.
      RETURN
C
C   ALLOW OVERLAP MODE FOR E&S. OBSOLETE.
C
 110  CONTINUE
      CALL TELLUSER1(NOTIMPL)
      RETURN
C
C   DISALLOW OVERLAP MODE
C
 115  CONTINUE
      CALL TELLUSER1(NOTIMPL)
      RETURN
C
C   FLAG USED AS DEBUGGING AID TO ALLOW THE
C   DISPLAY SUBROUTINE TO FUNCTION NORMALLY...
C
 120  SKIPDISP=.FALSE.
      DCHANGE=.TRUE.
      RETURN
C
C   OR TO CAUSE IT TO RETURN WITHOUT DOING ANYTHING.
C
 125  SKIPDISP=.TRUE.
      DCHANGE=.TRUE.
      RETURN
C
C   ALLOWS THE SPILL VALUE FOR UDL BUFFERING TO
C   BE MODIFIED.  SEE THE DISPLAY SUBROUTINE FOR
C   MORE INFORMATION ABOUT THIS VARIABLE.
C
 130  CONTINUE
      VPOINT=POINT
      CALL GETVLU(ARG,POINT,IVAL,ADDIT)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      IF( (IVAL.GT.UDLIMIT).OR.(IVAL.LE.0) )THEN
        POINT=VPOINT
        CALL TELLUSER(SPILBAD,*999)
      END IF
      DO 131 I=1,NOBJ
      IF(IVAL.LE.SIZEOBJ(I) )THEN
        POINT=VPOINT
        CALL TELLUSER(SPILBAD,*999)
      END IF
 131  CONTINUE
      SPILL=IVAL
      DCHANGE=.TRUE.
      RETURN
C
C   ALLOWS THE MAXIMUM DEPTH FOR STACK PUSHES
C   (ALSO KNOWN AS GROUPING OR NESTING) TO
C   BE CHANGED.  THE E&S SOFTWARE PACKAGE IS
C   QUITE INCONSISTENT ABOUT WHAT IT ALLOWS
C   SO I MUST BE AS CONSERVATIVE AS THEY AND
C   ONLY ALLOW 8 LEVELS, UNLESS YOU'RE USING
C   THE MODFIED SUBROUTINE LIBRARY WHICH ALLOWS
C   12 - THE REAL HARDWARE LIMIT!
C
 140  CONTINUE
      VPOINT=POINT
      CALL GETVLU(ARG,POINT,IVAL,ADDIT)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      IF(IVAL.GT.1 .AND. IVAL.LT.STACKSIZE)THEN
        MAXDEPTH=IVAL
      ELSE
        POINT=VPOINT
        CALL TELLUSER(BADVALUE,*999)
      END IF
      RETURN
C
C   SET THE FRAME COUNTER TO A USER GIVEN VALUE.
C   THIS COUNTER IS INCREMENTED BY ADVANCE.
C
 150  CALL GETVLU(ARG,POINT,IVAL,ADDIT)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      FCOUNT=IVAL
      RETURN
C
C   ALLOW COMMAND LINES TO BE ECHOED WHEN THEY ARE
C   BEING INTERPRETED.  THIS WILL ECHO ALL COMMANDS,
C   UNLIKE VERIFY WHICH PRINTS ONLY COMMAND RETRIEVED
C   FROM A .GIN FILE.
C
 160  ECHO = .TRUE.
      RETURN
C
 165  ECHO = .FALSE.
      RETURN
C
C   SET THE FLAG CONTROLLING TRANSLATION FROM LOWER TO UPPER
C
 170  LOWERCASE=.TRUE.
      RETURN
C
 175  LOWERCASE=.FALSE.
      RETURN
C
C   ENABLE/DISABLE REPORTING OF ERROR MESSAGES
C
 180  REPORT=.TRUE.
      RETURN
C
 185  REPORT=.FALSE.
      RETURN
C
C   TURN ON/OFF THE AUTO CURSOR.  BEWARE THAT HITTESTING
C   MAY ALREADY HAVE IT ON AND DISALLOW TURNING IT OFF
C   IF HITTESTING IS ACTIVE.
C
 190  CONTINUE
      CALL GROUT('SET CURSOR NOT AVAILABLE')
C     IF(.NOT.(HITTING.OR.CURSOR))THEN
C   CALL LSPEED(3)
C   CALL LCOLOR(30,0)
C   CALL PAUTO(TABLETS,CROSS)
C     END IF
C     CURSOR=.TRUE.
      RETURN
C
 195  CONTINUE
      CALL GROUT('SET NOCURSOR NOT AVAILABLE')
C     IF(CURSOR.AND..NOT.HITTING)CALL PAUTO(CROSS,CROSS)
C     CURSOR=.FALSE.
      RETURN
C
C   ALLOW EITHER SINGLE OR DBLMODE BUFFERING OF THE
C   DISPLAY MEMORY
C
 200  CONTINUE
      DBLMODE=.TRUE.
      CALL G0MODES
      RETURN
C
 205  CONTINUE
      DBLMODE=.FALSE.
      CALL G0MODES
      RETURN
C
C   ALLOW OR DISALLOW THE PEN TO STOP ADVANCES
C
 210  CONTINUE
      Call Telluser1(NOTIMPL)
      RETURN
C
 215  CONTINUE
      Call Telluser1(NOTIMPL)
      RETURN
C
 220  CONTINUE
      WINVRT=.FALSE.
      DCHANGE=.TRUE.
      RETURN
C
 225  CONTINUE
      WINVRT=.TRUE.
      DCHANGE=.TRUE.
      RETURN
C
 230  CONTINUE
      IF(OUTTING.NE.OUTNONE .AND. OUTTING.NE.OUTNIL
     &  .AND. OUTTING.NE.OUTWINDOW) CALL TELLUSER(ONEOUT,*999)
      IF(POINT.EQ.0)THEN
        OUTTYPE=' '
      ELSE
        VPOINT=POINT
        CALL GETSTR(ARG,POINT,OUTTEMP)
        OUTTYPE=OUTTEMP
        CALL UPCASE(OUTTYPE)
        OTEND=TRIM(OUTTYPE)
      END IF
C
      IF      ( OUTTYPE.EQ.'NIL')THEN
        CLOSE (UNIT=OFILE)
        OUTTING=OUTNIL
      ELSE IF ( OUTTYPE.EQ.'PLOT10' )THEN
        OPEN(UNIT=OFILE,FILE='TT:',STATUS='OLD')
        OUTTING=OUTTEK4010
      ELSE IF ( OUTTYPE .EQ. 'SCREEN'   .OR.
     &      OUTTYPE .EQ. 'WINDOW'   .OR.
     &      OUTTYPE .EQ. 'NOBORDER' .OR.
     &      OUTTYPE .EQ. 'IRIS' )   THEN
      XORI=0
      YORI=0
      XSIZ=0
      YSIZ=0
      IF(POINT.NE.0)THEN
        CALL GETSTR(ARG,POINT,OUTTEMP)
         CALL UPCASE(OUTTEMP)
        I=INDEX(OUTTEMP,'X')
        IF(I.NE.0)OUTTEMP(I:I)=','
        I=INDEX(OUTTEMP,'+')
        IF(I.NE.0)OUTTEMP(I:I)=','
        I=INDEX(OUTTEMP,'+')
        IF(I.NE.0)OUTTEMP(I:I)=','
        POINT=1
         CALL GETVLU(OUTTEMP,POINT,XSIZ,DUMMY)
        IF(ERROR.NE.0)CALL TELLUSER(ERROR, *999)
         IF(POINT.NE.0)CALL GETVLU(OUTTEMP,POINT,YSIZ,DUMMY)
        IF(ERROR.NE.0)CALL TELLUSER(ERROR, *999)
         IF(POINT.NE.0)CALL GETVLU(OUTTEMP,POINT,XORI,DUMMY)
        IF(ERROR.NE.0)CALL TELLUSER(ERROR, *999)
         IF(POINT.NE.0)CALL GETVLU(OUTTEMP,POINT,YORI,DUMMY)
        IF(ERROR.NE.0)CALL TELLUSER(ERROR, *999)
      END IF
      IF(OUTTING.EQ.OUTWINDOW)THEN
        CALL G0WSET(XORI,YORI,XSIZ,YSIZ,1)
        RETURN
      ELSE
        OUTTING=OUTWINDOW
        If(OUTTYPE.EQ.'NOBORDER')Then
          BORDER=.FALSE.
        Else
          BORDER=.TRUE.
        End If
         CALL G0INIT(XSIZ,YSIZ,XORI,YORI,BORDER)
      END IF
      ELSE IF ( OUTTYPE.EQ.'RAMTEK' )THEN
        OPEN(UNIT=OFILE,FILE='TT:',STATUS='OLD')
        OUTTING=OUTRAMTEK
      ELSE IF ( OUTTYPE.EQ.'VT220' )THEN
        OPEN(UNIT=OFILE,FILE='TT:',STATUS='OLD')
        OUTTING=OUTVT220
      ELSE
        IF(OUTTYPE.NE.BLANK)THEN
          OUTFILE=OUTTEMP
          APPEND=' '
        ELSE
          IF(OUTFILE.EQ.BLANK)CALL TELLUSER(NONAME,*999)
          APPEND='APPEND'
        END IF
        DEFEXT='qix'
        ERROR=OPENFILE(OUTFILE,OFILE,.TRUE.,APPEND)
        IF(ERROR.NE.0)THEN
          POINT=VPOINT
          CALL TELLUSER(ERROR,*999)
        ELSE
C
C   REST IS IN COMMON AND IS EXT + VERSION NUMBER
C   AFTER CONSULTING EXT, REPLACE OUTFILE WITH FULL
C   VAX FILE NAME, FOR LATER REFERENCE.
C
          EXT=REST(1:3)
          CALL UPCASE(EXT)
          IF (EXT.EQ.'QIX')THEN
            OUTTING=OUTQIX
          ELSE IF (EXT.EQ.'PIX')THEN
            OUTTING=OUTPIX
          ELSE IF(EXT.EQ.'PS')THEN
            OUTTING=OUTPOSTSCR
          Call PSHEAD(OFILE)
          ELSE IF(EXT.EQ.'RAY')THEN
            OUTTING=OUTRAYT
          Call RAYTHEAD
          ELSE IF(EXT.EQ.'TDL')THEN
            OUTTING=OUTTDL
            WRITE(OFILE,2000)MINUS2,ZERO,ONE
          ELSE IF(EXT.EQ.'ASC')THEN
            OUTTING=OUTASC
          ELSE
            POINT=VPOINT
            CALL TELLUSER(BADOUTTYPE,*235)
          END IF
          INQUIRE(UNIT=OFILE,NAME=OUTFILE)
        END IF
      END IF
      RETURN
C
 235  CONTINUE
C
C   OUTTING.GT.0 IMPLIES OUTPUT WAS TO A DEVICE,
C   OUTTING.LT.0 IMPLIES OUTPUT WAS TO A FILE.
C
      IF(OUTTING.GT.0)THEN
         CALL G0DONE
      ELSE IF(OUTTING.LT.0)THEN
         IF(OUTTING.EQ.OUTTDL)WRITE(OFILE,2000)MINUS5,ZERO,ZERO
         CLOSE (UNIT=OFILE)
      END IF
      OUTTING=OUTNONE
      RETURN
C
C   SET BACKGROUND COLOR
C
 240  CONTINUE
      IF(POINT.NE.0)THEN
        VPOINT=POINT
        CALL GETVLU(ARG,POINT,IVAL,ADDIT)
        IF(ERROR.NE.0)THEN
          POINT=VPOINT
          CALL TELLUSER(ERROR,*999)
        ELSE
          CALL G0DBKCOL(IVAL/255.,IVAL/255.,IVAL/255.)
          DCHANGE=.TRUE.
        END IF
      END IF
      RETURN
C
C   SET SOFTWARE FONT
C
 250  CONTINUE
      IF(POINT.EQ.0)THEN
        CALL G0DXTSCALE(100)
        CALL G0DYTSCALE(100)
        FFONT='Helvetica'
      ELSE
      VPOINT=POINT
        CALL GETSTR(ARG,POINT,FFONT)
C   CALL UPCASE(FFONT)
        IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
        IF (FFONT.EQ.BLANK)FFONT='Helvetica'
      CALL G0DFONT(0)
      If(ERROR.NE.0)Then
        POINT=VPOINT
        Call Telluser(ERROR, *999)
      End If
        DCHANGE=.TRUE.
      End If
C Could be zero because of no args, or one arg (zero after call to GETSTR)
      IF(POINT.NE.0)THEN
        VPOINT=POINT
        CALL GETSTR(ARG,POINT,ATSIZE)
        IF(ERROR.EQ.0)TTSIZE=A2I(ATSIZE,ERROR)
        IF(TTSIZE.LE.0.)ERROR=BADVALUE
        IF(ERROR.NE.0)THEN
          POINT=VPOINT
          CALL TELLUSER(ERROR,*999)
        END IF
        CALL G0DXTSCALE(TTSIZE)
        IF(POINT.NE.0)THEN
          VPOINT=POINT
          CALL GETSTR(ARG,POINT,ATSIZE)
          IF(ERROR.EQ.0)TTSIZE=A2I(ATSIZE,ERROR)
          IF(TTSIZE.LE.0.)ERROR=BADVALUE
          IF(ERROR.NE.0)THEN
            POINT=VPOINT
            CALL TELLUSER(ERROR,*999)
          END IF
          CALL G0DYTSCALE(TTSIZE)
        ELSE
          CALL G0DYTSCALE(XTSIZE)
        END IF
      END IF
C
      DCHANGE=.TRUE.
      RETURN
C
C   BITMAP FONT
C
 255  CONTINUE
      IF(POINT.NE.0)THEN
        VPOINT=POINT
        CALL GETVLU(ARG,POINT,IVAL,ADDIT)
        IF(ERROR.NE.0)THEN
          POINT=VPOINT
          CALL TELLUSER(ERROR,*999)
        ELSE
          CALL G0DFONT(IVAL)
          If(ERROR.NE.0)Then
            POINT=VPOINT
            Call Telluser(ERROR, *999)
          End If
          DCHANGE=.TRUE.
        END IF
      END IF
      RETURN
C
 260  CONTINUE
      IF(POINT.EQ.0)THEN
        GRLIB=BLANK
      ELSE
        VPOINT=POINT
        CALL GETSTR(ARG,POINT,SAVDIR)
        GRLIB=SAVDIR
      END IF
      RETURN
C
 270  CONTINUE
      HIDESMODE=.TRUE.
      DCHANGE=.TRUE.
      RETURN
C
 275  CONTINUE
      HIDESMODE=.FALSE.
      DCHANGE=.TRUE.
      RETURN
C
 280  CONTINUE
      CALL G0SHADEM(0)
      DCHANGE=.TRUE.
      RETURN
C
 285  CONTINUE
      CALL G0SHADEM(1)
      DCHANGE=.TRUE.
      RETURN
C
 290  CONTINUE
      SMOLIN=.TRUE.
      call setsmooth(1)
      DCHANGE=.TRUE.
      RETURN
C
 295  CONTINUE
      SMOLIN=.FALSE.
      call setsmooth(0)
      DCHANGE=.TRUE.
      RETURN
C
 300  CONTINUE
      BACKFACE=0
      if (outting.eq.OUTWINDOW)CALL BACKFA(0)
      DCHANGE=.TRUE.
      RETURN
C
 305  CONTINUE
C backface set color or scales
      If(MATCH(SWITCHES,'COLOR'))Then
C parse HSV to set constant RGB backface color
        BACKFACE=1
      Else
C diffuse, specular scale factors
        BACKFACE=-1
      End If
      If (POINT.EQ.0) Then
C default is quarter ambient, full diffuse, no specular
        RVAL = 0.25
        GVAL = 1.0
        BVAL = 0.0
      Else
        CALL GETSTR(ARG,POINT,RTMP)
        If (BACKFACE .EQ. 1)Then
          HUE=A2F(RTMP,ERROR)/UNITS(UCHUE)*360
        Else
          RVAL=A2F(RTMP,ERROR)
        End If
        IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)

        CALL GETSTR(ARG,POINT,RTMP)
        If (BACKFACE .EQ. 1)Then
          SAT=A2F(RTMP,ERROR)/UNITS(UCSAT)
        Else
          GVAL=A2F(RTMP,ERROR)
        End If
        IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)

        CALL GETSTR(ARG,POINT,RTMP)
        If (BACKFACE .EQ. 1)Then
          VALU=A2F(RTMP,ERROR)/UNITS(UCVAL)
        Else
          BVAL=A2F(RTMP,ERROR)
        End If
        IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)

        If (BACKFACE .EQ. 1)Then
          IHUE= MOD(INT(120+HUE),  360)
          ISAT= MOD(INT(100*SAT),  101)
          IVALU=MOD(INT(100*VALU), 101)
          CALL HSVRGB(IHUE, ISAT, IVALU, RVAL, GVAL, BVAL)
        End If
      End If
      CALL G0DBFCOL(RVAL,GVAL,BVAL)
      If (outting.eq.OUTWINDOW)CALL BACKFA(1)
      DCHANGE=.TRUE.
      RETURN
C
 310  CONTINUE
      CALL G0SETRGBMODE(.TRUE.)
      CALL G0MODES
      RETURN
C
 315  CONTINUE
      CALL G0SETRGBMODE(.FALSE.)
      CALL G0MODES
      RETURN
C
 320  CONTINUE
      CALL GETSTR(ARG,POINT,RTMP)
      RVAL=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      CALL G0SETSPEC(RVAL)
      DCHANGE=.TRUE.
      RETURN
C
 330  CONTINUE
      CALL GETSTR(ARG,POINT,RTMP)
      RVAL=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      CALL G0SETDIFF(RVAL)
      DCHANGE=.TRUE.
      RETURN
C
 340  CONTINUE
      CALL GETSTR(ARG,POINT,RTMP)
      RVAL=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      CALL G0SETAMBI(RVAL)
      DCHANGE=.TRUE.
      RETURN
C
 350  CONTINUE
      CALL GETSTR(ARG,POINT,RTMP)
      RVAL=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      CALL G0SETEMIS(RVAL)
      DCHANGE=.TRUE.
      RETURN
C
 360  CONTINUE
      CALL GETSTR(ARG,POINT,RTMP)
      RVAL=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      CALL G0SETSHIN(RVAL)
      DCHANGE=.TRUE.
      RETURN
C
 370  CONTINUE
      CALL GETSTR(ARG,POINT,RTMP)
      RVAL=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      CALL GETSTR(ARG,POINT,RTMP)
      GVAL=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      CALL GETSTR(ARG,POINT,RTMP)
      BVAL=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      CALL G0DBKCOL(RVAL,GVAL,BVAL)
      DCHANGE=.TRUE.
      RETURN
C
 380  CONTINUE
      CALL GETSTR(ARG,POINT,RTMP)
      HUE=A2F(RTMP,ERROR)/UNITS(UCHUE)*360
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      CALL GETSTR(ARG,POINT,RTMP)
      SAT=A2F(RTMP,ERROR)/UNITS(UCSAT)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      CALL GETSTR(ARG,POINT,RTMP)
      VALU=A2F(RTMP,ERROR)/UNITS(UCVAL)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      IHUE= MOD(INT(120+HUE),  360)
      ISAT= MOD(INT(100*SAT),  101)
      IVALU=MOD(INT(100*VALU), 101)
      CALL HSVRGB(IHUE, ISAT, IVALU, RVAL, GVAL, BVAL)
      CALL G0DBKCOL(RVAL,GVAL,BVAL)
      DCHANGE=.TRUE.
      RETURN
C
C ALPHABLEND
 390  CONTINUE
      If (POINT.NE.0) Then
        CALL GETVLU(ARG,POINT,SOURCE,ADDIT)
        IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
        CALL GETVLU(ARG,POINT,DESTIN,ADDIT)
        IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
        CALL G0BLEND(SOURCE, DESTIN)
      Else
        CALL G0BLEND(4,5)
      End If
      DCHANGE=.TRUE.
      RETURN
C
C NOALPHABLEND
 395  CONTINUE
      CALL G0BLEND(-1, -1)
      DCHANGE=.TRUE.
      RETURN
C
C CYLINDERS
 400  CONTINUE
      CALL GETSTR(ARG,POINT,RTMP)
      LORES=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      CALL GETSTR(ARG,POINT,RTMP)
      HIRES=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      LON = INT(LORES)
      HIN = INT(HIRES)
      LOREP = NINT ((LORES - LON) * 10.)
      HIREP = NINT ((HIRES - HIN) * 10.)
      If(OUTTING.EQ.OUTWINDOW)CALL G0CYLREDO(LON, LOREP, HIN, HIREP)
      DCHANGE=.TRUE.
      RETURN
C
C TWIST - unused now?
 410  CONTINUE
      CALL TELLUSER(NEVER,*999)
      RETURN
C
C SPHERES
 420  CONTINUE
      CALL GETSTR(ARG,POINT,RTMP)
      LORES=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      CALL GETSTR(ARG,POINT,RTMP)
      HIRES=A2F(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      LON = INT(LORES)
      HIN = INT(HIRES)
      LOREP = NINT ((LORES - LON) * 10.)
      HIREP = NINT ((HIRES - HIN) * 10.)
      If(OUTTING.EQ.OUTWINDOW)CALL G0SPHREDO(LON, LOREP, HIN, HIREP)
      DCHANGE=.TRUE.
      RETURN
c
 430  CONTINUE
      IF(REROUTE.EQ.ACTIVE)Then
      Write(RFILE,'(a,a)')'!COMMANDOUT file overide: SET ',
     &    ARG(:TRIM(ARG))
      Close(UNIT=RFILE)
      End If
      IF(POINT.NE.0)THEN
        VPOINT=POINT
        CALL GETSTR(ARG,POINT,RERFILE)
        DEFEXT='out'
      ELSE
        RERFILE='/usr/tmp/gramps.out'
      END IF
      APPEND=' '
      ERROR=OPENFILE(RERFILE,RFILE,.TRUE.,APPEND)
      IF(ERROR.NE.0)THEN
        POINT=VPOINT
        CALL TELLUSER(ERROR,*999)
      ELSE
        REROUTE=PENDING
      RERFILE=FULLFILE
      Write(RFILE,'(a)')'!SET COMMANDOUT '//RERFILE(:TRIM(RERFILE))
c    SKIPCOLL=.TRUE.
      END IF
      Close(UNIT=RFILE)
      RETURN
C
C Keys
 440  Continue
      IF(POINT.NE.0)THEN
        VPOINT=POINT
        CALL GETSTR(ARG,POINT,KEYTYP)
        CALL UPCASE(KEYTYP)
        If (KEYTYP .EQ. 'ON') Call setkeys(1)
        If (KEYTYP .EQ. 'OFF') Call setkeys(0)
        If (KEYTYP .EQ. 'STICKY') Call setkeys(-1)
      ELSE
        Call setkeys(1)
      End If
      Return
C
C OLD or NEW units.  If /ALL make it system-wide, else local to this
C gin file (AGF level).
 450  Continue
      If(MATCH(SWITCHES,'GLOBAL'))Then
        SCOPE=1
      Else
        SCOPE=AGF
      End If
      TUNITS(SCOPE)=OLDUNITS
      Call setunits(OLDUNITS)
      Return
C
 460  Continue
      If(MATCH(SWITCHES,'GLOBAL'))Then
        SCOPE=1
      Else
        SCOPE=AGF
      End If
      TUNITS(SCOPE)=NEWUNITS
      Call setunits(NEWUNITS)
      Return
C
 470  Continue
c  Call menu_on
      Return
C
 480  Continue
c  Call menu_off
      Return
C
 490    Continue
      CALL GETSTR(ARG,POINT,RTMP)
      IVAL=A2I(RTMP,ERROR)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*999)
      Call g0normalization(IVAL)
      DCHANGE=.TRUE.
      Return
C
 999  RETURN
 2000 FORMAT(4I7)
      END
C
C
C----------------------------------------------------------------------
C
      SUBROUTINE RIGHTON
C
C   THIS SUBROUTINE IS USED TO ACTIVATE THE RWORLD.  IT
C   IS CALLED BY SET STEREO.
C   TVAL IS AMOUNT TO TRANSLATE.  MVAL AMOUNT TO MOVE.
C
      IMPLICIT NONE
C
#include "UDLIST.FOR"
C#include "DEVICES.FOR"
      INTEGER I 
C
C   COPY LWORLD TRANSFORMATIONS INTO RWORLD.
C
      CALL TRANSCOPY(LWORLD,RWORLD)
C
C   DON'T FORGET THOSE EXTRA WORLD-ONLY TFMS!
C
      DO 12 I=1,WTFM
      WLDVAL (I,RWORLD)=WLDVAL (I,LWORLD)
      WLDINC (I,RWORLD)=WLDINC (I,LWORLD)
      FNWLD  (I,RWORLD)=FNWLD  (I,LWORLD)
      DEVWLD (I,RWORLD)=DEVWLD (I,LWORLD)
      LWBOUND(I,RWORLD)=LWBOUND(I,LWORLD)
      UWBOUND(I,RWORLD)=UWBOUND(I,LWORLD)
      WLDANG (I,RWORLD)=WLDANG (I,LWORLD)
      DWFACT (I,RWORLD)=DWFACT (I,LWORLD)
 12   CONTINUE
      DEVWLD (WSUMMRY,RWORLD)=DEVWLD (WSUMMRY,LWORLD)
      FNWLD  (WSUMMRY,RWORLD)=FNWLD  (WSUMMRY,LWORLD)
C
      RETURN
C
      ENTRY RIGHTOFF
C
C   TO DEACTIVATE RWORLD.  CALLED BY SET NOSTEREO AND NOALTSTEREO.
C
      DEVWLD (WSUMMRY,RWORLD)=0
      FNWLD  (WSUMMRY,RWORLD)=0
C
      RETURN
      END
