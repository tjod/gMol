C *************************************************************
C This file contains source code for the gMol computer program
C  Copyright (C) 1981-2010 by TJ O'Donnell and
C  Copyright (C) 2005-2010 gNova, Inc.
C It is unlawful to modify or remove this copyright notice.
C See the accompanying LICENSE file for further information. 
C *************************************************************
      SUBROUTINE FNUPDATE(IID,TFMTYP,DEVTYP,VALL,RELL)
C
	IMPLICIT NONE
	INTEGER IID, TFMTYP, DEVTYP
	REAL VALL, RELL
C
C#include "DEVICES.FOR"
#include "UDLIST.FOR"
C
      REAL NEWVAL,NEWINC
C
C       FIRST CHECK FOR THE "NEGATIVE" SPECIAL FUNCTION
C       WHICH MEANS NEGATE THE UPDATING VALUE, THEN CHECK
C       FOR THE "FACTOR" SPECIAL FUNCTION WHICH PROVIDES
C       A DIVISOR FOR THE UPDATING VALUE.  MOUSE ARE
C       UPDATED REALTIVE TO THEIR CURRENT VALUE, WHEREAS
C       SPINS, DIALS and SLIDES ARE ABSOLUTE DEVICES.
C
C
      IF(DEVTYP.EQ.MOUSS)THEN
        NEWVAL=TFMVAL(TFMTYP,IID)
        NEWINC=TFMINC(TFMTYP,IID)
        IF( BTEST(FNUSE(TFMTYP,IID),BNEGDEV) )THEN
          IF( BTEST(FNUSE(TFMTYP,IID),BFACT) )THEN
            NEWVAL=NEWVAL - RELL*DFACT(TFMTYP,IID)
            NEWINC=NEWINC - RELL*DFACT(TFMTYP,IID)
          ELSE
            NEWVAL=NEWVAL - RELL
            NEWINC=NEWINC - RELL
          END IF
        ELSE
          IF( BTEST(FNUSE(TFMTYP,IID),BFACT) )THEN
            NEWVAL=NEWVAL + RELL*DFACT(TFMTYP,IID)
            NEWINC=NEWINC + RELL*DFACT(TFMTYP,IID)
          ELSE
            NEWVAL=NEWVAL + RELL
            NEWINC=NEWINC + RELL
          END IF
        END IF
      ELSE
        IF( BTEST(FNUSE(TFMTYP,IID),BNEGDEV) )THEN
          IF( BTEST(FNUSE(TFMTYP,IID),BFACT) )THEN
            NEWVAL=-VALL*DFACT(TFMTYP,IID)
            NEWINC=-VALL*DFACT(TFMTYP,IID)
          ELSE
            NEWVAL=-VALL
            NEWINC=-VALL
          END IF
        ELSE
          IF( BTEST(FNUSE(TFMTYP,IID),BFACT) )THEN
            NEWVAL=VALL*DFACT(TFMTYP,IID)
            NEWINC=VALL*DFACT(TFMTYP,IID)
          ELSE
            NEWVAL=VALL
            NEWINC=VALL
          END IF
        END IF
      END IF
C
C       NOW CHECK FOR "ADDINC" SPECIAL FUNCTION WHICH MEANS
C       THAT THE UPDATING VALUE IS NOT A TRANSFORMATION VALUE
C       BUT RATHER A TRANSFORMATION VALUE INCREMENT.
C       JUST SET THE INCREMENT...CONTUPD SUBROUTINE ACTUALLY
C       DOES THE INCREMENTING EVERY DISPLAY CYCLE.
C
      IF( BTEST(FNUSE(TFMTYP,IID),BADDINC) )THEN
        TFMINC(TFMTYP,IID)=NEWINC
        RETURN
      END IF
C
C       FINALLY CHECK FOR A "BOUNDED" SPECIAL FUNCTION
C       AND TAKE CARE OF THE "BOUNCE" SPECIAL FUNCTION
C	And take care of the "WRAP" special function
C       IF THATS ACTIVE, TOO.
C
      IF( BTEST(FNUSE(TFMTYP,IID),BBOUNDED) )THEN
        IF(NEWVAL.GT.UBOUND(TFMTYP,IID))THEN
          IF( BTEST(FNUSE(TFMTYP,IID),BWRAP) )THEN
            NEWVAL=LBOUND(TFMTYP,IID) + (NEWVAL-UBOUND(TFMTYP,IID))
          ELSE
            NEWVAL=UBOUND(TFMTYP,IID)
            IF( BTEST(FNUSE(TFMTYP,IID),BBOUNCE) )
     &        FNUSE(TFMTYP,IID)=IEOR(FNUSE(TFMTYP,IID),FNEGDEV)
          END IF
        ELSE
          IF(NEWVAL.LT.LBOUND(TFMTYP,IID))THEN
            IF( BTEST(FNUSE(TFMTYP,IID),BWRAP) )THEN
              NEWVAL=UBOUND(TFMTYP,IID) + (NEWVAL-LBOUND(TFMTYP,IID))
            ELSE
              NEWVAL=LBOUND(TFMTYP,IID)
              IF( BTEST(FNUSE(TFMTYP,IID),BBOUNCE) )
     &          FNUSE(TFMTYP,IID)=IEOR(FNUSE(TFMTYP,IID),FNEGDEV)
            END IF
          END IF
        END IF
      END IF
C
C       NOW THAT NEWVAL HAS BEEN UPDATED, FILL THE
C       TFMVAL ARRAY THAT HOLDS THE CURRENT VALUES.
C	  THEN UPDATE THE UDL WITH THE NEW INFO
C	  LABRATORY FRAME-OF-REFERENCE ROTATIONS REQUIRE COMPLEX
C	  UPDATING, INVOLVING ALL THREE AXES SIMULTANEOUSLY.
C
	IF( BTEST(FNUSE(TFMTYP,IID),BLABROT) )THEN
		CALL LABROT(IID,NEWVAL,TFMTYP)
	ELSE
		TFMVAL(TFMTYP,IID)=NEWVAL
C		CALL USHOW(IID,TFMTYP)
	END IF
C
	RETURN
	END
C
      SUBROUTINE FNUPDWLD(IID,TFMTYP,DEVTYP,VALL,RELL)
C
	IMPLICIT NONE
	INTEGER IID, TFMTYP, DEVTYP
	REAL VALL, RELL
C
C#include "DEVICES.FOR"
#include "UDLIST.FOR"
C
      REAL NEWVAL,NEWINC
C
C       THIS SUBROUTINE IS ANALOGOUS TO THE FNUPDATE
C       BUT OPERATES ONLY ON THE WORLDS BY CONSIDERING
C       THE SPECIAL TRANSFORMATIONS (PERSPECTIVE AND MOVE)
C       WHICH CAN APPLY ONLY TO THE WORLDS
C
C
      IF(DEVTYP.EQ.MOUSS) Then
        NEWVAL=WLDVAL(TFMTYP,IID)
        NEWINC=WLDINC(TFMTYP,IID)
        IF( BTEST(FNWLD(TFMTYP,IID),BNEGDEV) )THEN
          IF( BTEST(FNWLD(TFMTYP,IID),BFACT) )THEN
            NEWVAL=NEWVAL - RELL*DWFACT(TFMTYP,IID)
            NEWINC=NEWINC - RELL*DWFACT(TFMTYP,IID)
          ELSE
            NEWVAL=NEWVAL - RELL
            NEWINC=NEWINC - RELL
          END IF
        ELSE
          IF( BTEST(FNWLD(TFMTYP,IID),BFACT) )THEN
            NEWVAL=NEWVAL + RELL*DWFACT(TFMTYP,IID)
            NEWINC=NEWINC + RELL*DWFACT(TFMTYP,IID)
          ELSE
            NEWVAL=NEWVAL + RELL
            NEWINC=NEWINC + RELL
          END IF
        END IF
      ELSE
        IF( BTEST(FNWLD(TFMTYP,IID),BNEGDEV) )THEN
          IF( BTEST(FNWLD(TFMTYP,IID),BFACT) )THEN
            NEWVAL=-VALL*DWFACT(TFMTYP,IID)
            NEWINC=-VALL*DWFACT(TFMTYP,IID)
          ELSE
            NEWVAL=-VALL
            NEWINC=-VALL
          END IF
        ELSE
          IF( BTEST(FNWLD(TFMTYP,IID),BFACT) )THEN
            NEWVAL=VALL*DWFACT(TFMTYP,IID)
            NEWINC=VALL*DWFACT(TFMTYP,IID)
          ELSE
            NEWVAL=VALL
            NEWINC=VALL
          END IF
        END IF
      END IF
C
      IF( BTEST(FNWLD(TFMTYP,IID),BADDINC) )THEN
        WLDINC(TFMTYP,IID)=NEWINC
        RETURN
      END IF
C
      IF( BTEST(FNWLD(TFMTYP,IID),BBOUNDED) )THEN
        IF(NEWVAL.GT.UWBOUND(TFMTYP,IID))THEN
          IF( BTEST(FNWLD(TFMTYP,IID),BWRAP) )THEN
            NEWVAL=LWBOUND(TFMTYP,IID) + (NEWVAL-UWBOUND(TFMTYP,IID))
          ELSE
            NEWVAL=UWBOUND(TFMTYP,IID)
            IF( BTEST(FNWLD(TFMTYP,IID),BBOUNCE) )
     &        FNWLD(TFMTYP,IID)=IEOR(FNEGDEV,FNWLD(TFMTYP,IID) )
          END IF
        ELSE
          IF(NEWVAL.LT.LWBOUND(TFMTYP,IID))THEN
            IF( BTEST(FNWLD(TFMTYP,IID),BWRAP) )THEN
              NEWVAL=UWBOUND(TFMTYP,IID) + (NEWVAL-LWBOUND(TFMTYP,IID))
            ELSE
              NEWVAL=LWBOUND(TFMTYP,IID)
              IF( BTEST(FNWLD(TFMTYP,IID),BBOUNCE) )
     &          FNWLD(TFMTYP,IID)=IEOR(FNEGDEV,FNWLD(TFMTYP,IID))
            END IF
          END IF
        END IF
      END IF
C
      WLDVAL(TFMTYP,IID)=NEWVAL
C      CALL WSHOW(IID,TFMTYP)
C
C
      RETURN
      END
C
	SUBROUTINE LABROT(IID,NEWVAL,TFMTYP)
C
        IMPLICIT NONE
        INTEGER IID, TFMTYP
	REAL NEWVAL
#include "ERRORS.FOR"
#include "UDLIST.FOR"
#include "DEFVAL.FOR"
C
        INTEGER UX,UY,UZ
        REAL AX,AY,AZ,DX,DY,DZ
	Real PI, ROTSCALE, IROTSCALE
	Parameter (PI=3.1415927)
        Parameter (ROTSCALE=PI*EROTX/180.)
	Parameter (IROTSCALE=1./ROTSCALE)
C
C	  SUBROUTINE TO DO A LABORATORY-FRAME-OF-REFERENCE
C	  ROTATION ON AN OBJECT.
C
C	  IID IS THE OBJECT NUMBER.
C	  NEWVAL IS THE NEW ROTATION VALUE.
C	  TFMTYP SPECIFIES WHICH AXIS ROTATION NEWVALUE APPLIES TO.
C
C	  TFMTYP COULD BE FOR X, Y, Z, P, Q OR R AXES.
C
	IF(	(TFMTYP.EQ.UROTXX) .OR . (TFMTYP.EQ.UROTYY) .OR.
     &		(TFMTYP.EQ.UROTZZ) )THEN
		UX=UROTXX
		UY=UROTYY
		UZ=UROTZZ
	ELSE IF((TFMTYP.EQ.UAROTX) .OR . (TFMTYP.EQ.UAROTY) .OR.
     &		(TFMTYP.EQ.UAROTZ) )THEN
		UX=UAROTX
		UY=UAROTY
		UZ=UAROTZ
	ELSE
		CALL TELLUSER(NEVER)
		RETURN
	END IF
C
C	  COMPUTE THREE NEW ROTATION VALUES, BASED ON THE ONE NEW VALUE.
C
	AX=TFMVAL(UX,IID)*ROTSCALE
	AY=TFMVAL(UY,IID)*ROTSCALE
	AZ=TFMVAL(UZ,IID)*ROTSCALE
	IF(TFMTYP.EQ.UX)THEN
		DX = NEWVAL*ROTSCALE - AX
		DY = 0.
		DZ = 0.
	ELSE IF(TFMTYP.EQ.UY)THEN
		DX = 0.
		DY = NEWVAL*ROTSCALE - AY
		DZ = 0.
	ELSE IF(TFMTYP.EQ.UZ)THEN
		DX = 0.
		DY = 0.
		DZ = NEWVAL*ROTSCALE - AZ
	END IF
	CALL RATROT(AX,AY,AZ,DX,DY,DZ)
C
C	  UPDATE ALL THREE ROTATION VALUES AND USHOW THE RESULTS.
C
	TFMVAL(UX,IID)=AX*IROTSCALE
	TFMVAL(UY,IID)=AY*IROTSCALE
	TFMVAL(UZ,IID)=AZ*IROTSCALE
C
C	  CALL USHOW TO UPDATE ALL THREE MATRICES IN DISPLAY LIST.
C
C	CALL USHOW(IID,UX)
C	CALL USHOW(IID,UY)
C	CALL USHOW(IID,UZ)
C
 	RETURN
	END
C
	SUBROUTINE RATROT(X,Y,Z,DX,DY,DZ)
	IMPLICIT NONE
	REAL X,Y,Z,DX,DY,DZ
C
	REAL SX, SY, SZ, CX, CY, CZ
	REAL TOP, BOT, SDY, CDY, SDZ, CDZ
C
C	  THIS ROUTINE WILL ACCEPT THREE ROTATION ANGLES, X, Y AND Z
C	  AND ONE DELTA ANGLE, EITHER DX, DY OR DZ.  THE DELTA ANGLE
C	  IT USES IS THE (BETTER BE ONLY) NON-ZERO ONE.  IT RETURNS
C	  THREE PRIMED ROTATION ANGLES, SUCH THAT:
C
C	  [RZ][RY][RZ][RDX] = [RZ'][RY'][RZ']
C		OR
C	  [RZ][RY][RZ][RDY] = [RZ'][RY'][RZ']
C		OR
C	  [RZ][RY][RZ][RDZ] = [RZ'][RY'][RZ']
C
C	  WHERE [RX] REPRESENTS AN X-ROTATION MATRIX, ETC.
C
C	  IT RETURNS THE PRIMED ANGLES IN THE VARIABLES USED TO INPUT
C	  THE ORIGINAL ANGLES.  SO, X, Y AND Z ARE ALWAYS MODIFIED AND
C	  DX, DY AND DZ ARE NEVER MODIFIED.
C
	Real TINY, PI
	PARAMETER (TINY=1.E-5)
	Parameter (PI=3.1415927)
C
	IF( DX .EQ. 0. .AND. DY .EQ. 0. .AND. DZ .EQ. 0.)RETURN
C
C	  SOME VALUES WILL BE NEEDED BY ALL THREE CASES.
C
	SX=SIN(X)
	CX=COS(X)
	SY=SIN(Y)
	CY=COS(Y)
	SZ=SIN(Z)
	CZ=COS(Z)
C
	IF     ( DX .EQ. 0. .AND. DY .EQ. 0.)THEN
		SDZ=SIN(DZ)
		CDZ=COS(DZ)
		TOP=SX*CY*CDZ - SY*SDZ 
		BOT=CX*CY
		IF(ABS(BOT).GT.TINY)THEN
			X=ATAN2(TOP,BOT)
		ELSE
			IF(TOP.LT.0)THEN
				X=-PI/2.
			ELSE
				X=PI/2.
			END IF
		END IF
C
		TOP=SZ*CY*CDZ + SDZ*(CZ*CX - SX*SY*SZ)
		BOT=CZ*CY*CDZ - SDZ*(CX*SZ + SX*CZ*SY)
		IF(ABS(BOT).GT.TINY)THEN
			Z=ATAN2(TOP,BOT)
		ELSE
			IF(TOP.LT.0)THEN
				Z=-PI/2.
			ELSE
				Z=PI/2.
			END IF
		END IF
C
		Y=ASIN(SX*CY*SDZ + SY*CDZ)
	ELSE IF( DX .EQ. 0. .AND.                  DZ .EQ. 0.)THEN
		SDY=SIN(DY)
		CDY=COS(DY)
		TOP=SX*CY
		BOT=CX*CY*CDY - SY*SDY
		IF(ABS(BOT).GT.TINY)THEN
			X=ATAN2(TOP,BOT)
		ELSE
			IF(TOP.LT.0)THEN
				X=-PI/2.
			ELSE
				X=PI/2.
			END IF
		END IF
C
		TOP=CDY*SZ*CY - SDY*(SX*CZ + CX*SY*SZ)
		BOT=CDY*CZ*CY + SDY*(SX*SZ - CX*SY*CZ)
		IF(ABS(BOT).GT.TINY)THEN
			Z=ATAN2(TOP,BOT)
		ELSE
			IF(TOP.LT.0)THEN
                                        Z=-PI/2.
                                ELSE
                                        Z=PI/2.
			END IF
		END IF
C
		Y=ASIN(SY*CDY + CX*CY*SDY)
	ELSE IF(                  DY .EQ. 0. .AND. DZ .EQ. 0.)THEN
		X=X+DX
		Y=Y+DY
		Z=Z+DZ
	ELSE
		CONTINUE
	END IF
C
	RETURN
	END
