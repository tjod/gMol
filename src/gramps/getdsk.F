C *************************************************************
C This file contains source code for the gMol computer program
C  Copyright (C) 1981-2010 by TJ O'Donnell and
C  Copyright (C) 2005-2010 gNova, Inc.
C It is unlawful to modify or remove this copyright notice.
C See the accompanying LICENSE file for further information. 
C *************************************************************
      Function GETDSK()
      IMPLICIT NONE
#include "UDLIST.FOR"
#include "FILES.FOR"
#include "ERRORS.FOR"
#include "DEFVAL.FOR"
      CHARACTER XYZPOS*80
      CHARACTER*1 BLANK
      CHARACTER*3 EXT
      CHARACTER*80 CHLINE
      CHARACTER*4 CHFONT
      CHARACTER*10 WLINE
      INTEGER NDIM, JDIM
      LOGICAL QIX
      REAL N, LDM1, LDM2, XBASE, YBASE, ZBASE, WBASE
      REAL XSCALE, YSCALE, HUE, SAT, VALU, IFRONT, ISIZE
      REAL XMOVE, YMOVE, ZMOVE, WMOVE
      CHARACTER*80 TMPLINE
      INTEGER SPOT, NTEST, UDSPOT, NT, I, J
      INTEGER CHLEN, TXTSIZ, TSIZE, TPOINT
      INTEGER BUFFSIZE
      EXTERNAL TRIM
      PARAMETER (BUFFSIZE=256)
      SAVE NDIM, QIX, WLINE, WBASE
c  DATA BLANK/' '/
      BLANK=' '
C
C   THIS SUBROUTINE PROCESSES THE INPUT OF A PIX
C   FILE, LOOKING FOR INFO LINES OR DATA LINES.
C
C   INTIALIZATION ENTRY
C
      ENTRY GETINIT
C
      NDIM=3
      EXT=REST(1:3)
      CALL UPCASE(EXT)
      IF(EXT.EQ.'QIX')THEN
        QIX=.TRUE.
      ELSE
        QIX=.FALSE.
      END IF
      RETURN
C
      ENTRY GETMORE
C
C   REST IS FILE EXTENSION + VERSION NUMBER (IN COMMON)
C
      SPOT=0
C
C   THE FIRST LINE MUST BE A INFO LINE
C
C   CHECK OUT THE POSSIBILITES
C        N>0  SPECIFIES A LINE TO BE DRAWN OF N POINTS
C        N=0  SPECIFIES A SPECIAL FUNCTION
C        N<0  END OF THIS OBJECT, BUT FILE HAS MORE OBJECTS (FRAMES)
C
 10   CONTINUE
      IF(QIX)THEN
        READ(PFILE,  END=999,ERR=26)N,LDM1,LDM2
      ELSE
        READ(PFILE,*,END=999,ERR=26)N,LDM1,LDM2
      END IF
      SPOT=SPOT+1
      IF(N)998,30,15
C
C   PROCESS THE N POINTS THAT FOLLOW, IN GROUPS OF
C   THE SIZE OF THE BUFFER.
C
 15   CONTINUE
      DLIST(UDFREE)=N
      DLIST(UDFREE+1)=LDM1
      DLIST(UDFREE+2)=LDM2
      UDFREE=UDFREE+3
      LENGTH=LENGTH+3
C
      NTEST=ABS(LDM2)
      IF(LDM1.EQ.8)THEN
C    IF(NTEST.EQ.2)GOTO 10
        JDIM=3
      ELSE IF(LDM1.GE.0 .AND. LDM1.LE.13)THEN
        IF(NTEST.EQ.1 .OR. NTEST.EQ.2 .OR.
     &     NTEST.EQ.5 .OR. NTEST.EQ.6)THEN
          JDIM=NDIM*2
        ELSE IF(NTEST.EQ.0 .OR. NTEST.EQ.7)THEN
          JDIM=NDIM+1
        ELSE
          JDIM=NDIM
        END IF
        IF(LDM1.EQ.9 .OR. LDM1.EQ.10)JDIM=JDIM+3
      END IF
C
      IF(QIX)THEN
      UDSPOT=UDFREE
        DO 20 NT=INT(N),1,-BUFFSIZE
        READ(PFILE,END=26,ERR=26)
     &    ((DLIST(UDSPOT-1+J+(I-1)*JDIM), J=1,JDIM),
     &        I=1,MIN(BUFFSIZE,NT) )
      UDSPOT=UDSPOT+BUFFSIZE*JDIM
 20     CONTINUE
      ELSE
        DO 25 I=1,INT(N)
        READ(PFILE,*,ERR=26,END=26)
     &    (DLIST(UDFREE-1+J+(I-1)*JDIM),J=1,JDIM)
 25     CONTINUE
      END IF
      SPOT=SPOT+N
      UDFREE = UDFREE + N*JDIM
      LENGTH = LENGTH + N*JDIM
      GOTO 10
C
C   SPECIAL FUNCTION REQUIRES LOOKING AT LDM1 TO
C   DETERMINE WHICH SPECIAL FUNCTION
C
 30   CONTINUE
      DLIST(UDFREE)=N
      DLIST(UDFREE+1)=LDM1
      DLIST(UDFREE+2)=LDM2
      UDFREE=UDFREE+3
      LENGTH=LENGTH+3
      GOTO (100,200,300,400,500,600,700,800,400,900) INT(LDM1 + 1)
C
C   IF WE GET HERE, AN ILLEGAL SPECIAL FUNCTION VALUE WAS SUPPLIED
C
 26   ERROR=GETPIXERR
      IF(FULLERR)THEN
      WRITE(TMPLINE,'(A,I8)')'AT LINE ',SPOT
      CALL GROUT(TMPLINE)
      END IF
      GOTO 999
C
C   SET THE BASE REGISTER FOR SUBSEQUENT DRAWS
C
 100  CONTINUE
C
C   IF LINE IS 0,0,0, the base is 0,0,0,32767;
C     Else 0,0,-X, READ THE BASE IN ON THE NEXT LINE
C   IF LINE IS 0,0,+W then make W be the current w factor.
C
      IF(LDM2.EQ.0)THEN
        XBASE=0.
        YBASE=0.
        ZBASE=0.
      If     (TUNITS(AGF).EQ.NEWUNITS)Then
           WBASE=1.
      Else If(TUNITS(AGF).EQ.OLDUNITS)Then
          WBASE=32767.
      End If
      Else IF(LDM2.LT.0)THEN
        IF(QIX)THEN
          READ(PFILE,ERR=26,END=26)XBASE,YBASE,ZBASE,WBASE
        ELSE
          READ(PFILE,*,ERR=26,END=26)XBASE,YBASE,ZBASE,WBASE
        END IF
        SPOT=SPOT+1
        DLIST(UDFREE)=XBASE
        DLIST(UDFREE+1)=YBASE
        DLIST(UDFREE+2)=ZBASE
        IF(WBASE.EQ.0.0)WBASE=1.
        DLIST(UDFREE+3)=WBASE
        UDFREE=UDFREE+4
        LENGTH=LENGTH+4
      ELSE
        WBASE=LDM2
      END IF
      GOTO 10
C
C  Set the cylinder radius or sphere radius ldm1=10
C   INFO ALREADY STORED AS N,LDM1,LDM2
C
 200  CONTINUE
      GOTO 10
C
C   MAKE THE FOLLOWING LINES DASHED.  LDM2 SPECIFIES
C   THE 16 POSSIBLE DASHED OPTIONS AVAILABLE.
C   THE "TENS" DIGIT MEANS CONTINUOUS TEXTURE.
C   SEE THE E&S SUPPLIED LDASH SUBROUTINE FOR MORE DETAILS.
C
C   NO CHECKING IS DONE HERE FOR ILLEGAL VALUES
C
 300  CONTINUE
      GOTO 10
C
C   INFO LINE IS 0,3,X
C   TEXT STRING TO BE DISPLAYED WITH CTEXTL
C   REQUIRES TWO OR THREE ADDITIONAL LINES OF INPUT:
C    1) THE COORDINATES OF THE TEXT
C    1a)OPTIONAL X Y SCALE AND FONT FOR SOFTWARE TEXT
C    2) THE TEXT STRING ITSELF: TRAILING BLANKS IGNORED
C
 400  CONTINUE
C     IF (CLSPOT.GE.MAXCL)THEN
C   CALL TELLUSER(CLOVER,*26)
C     ELSE
C   CLSPOT=CLSPOT+1
C     END IF
C
C   IF INFO LINE IS 0,8,X THEN USE SOFTWARE TEXT AND
C   READ XY SCALE AND FONT
C
      IF(QIX)THEN
        READ(PFILE,ERR=26,END=26)XYZPOS
        IF(LDM1.EQ.8)THEN
          READ(PFILE,ERR=26,END=26)CHFONT,XSCALE,YSCALE
        ELSE
          XSCALE=100
          YSCALE=100
          CHFONT='    '
        END IF
        READ(PFILE,ERR=26,END=26)CHLINE
      ELSE
        READ(PFILE,4000,ERR=26,END=26)XYZPOS
        IF(LDM1.EQ.8)THEN
          READ(PFILE,*,ERR=26,END=26)CHFONT,XSCALE,YSCALE
        ELSE
          XSCALE=100
          YSCALE=100
          CHFONT='    '
        END IF
        READ(PFILE,4000,ERR=26,END=26)CHLINE
      END IF
      SPOT=SPOT+2
      CHLEN=TRIM(CHLINE)
C
C   HANDLE THE X,Y,Z JUST LIKE THE TEXT COMMAND DOES
C
      IF( (LDM2.GT.0).AND.(LDM2.LE.8) )THEN
        TXTSIZ=LDM2
      ELSE
        TXTSIZ=TSIZE
      END IF
      TPOINT=1
      CALL TEXTXYZ(XYZPOS,TPOINT,CHLEN,TXTSIZ,XMOVE,YMOVE,ZMOVE,WMOVE)
      IF(ERROR.NE.0)CALL TELLUSER(ERROR,*26)
      DLIST(UDFREE)  =XMOVE
      DLIST(UDFREE+1)=YMOVE
      DLIST(UDFREE+2)=ZMOVE
      DLIST(UDFREE+3)=WMOVE
      UDFREE=UDFREE+4
      LENGTH=LENGTH+4
C
      DLIST(UDFREE)   = XSCALE
      DLIST(UDFREE+1) = YSCALE
      DO 405 I=1,4
      DLIST(UDFREE+1+I)=ICHAR(CHFONT(I:I))
 405  CONTINUE
      UDFREE=UDFREE+6
      LENGTH=LENGTH+6
C
      DLIST(UDFREE)=CHLEN
      UDFREE=UDFREE+1
      LENGTH=LENGTH+1
C
      DO 404 I=1,CHLEN
      DLIST(UDFREE+I-1)=ICHAR(CHLINE(I:I))
404   CONTINUE
      UDFREE=UDFREE+CHLEN
      LENGTH=LENGTH+CHLEN
C
      GOTO 10
 4000 FORMAT(A)
C
C   SET THE COLOR FOR THIS PICTURE.
C   READ THE NEXT WORD WHICH HAS HUE, SATURATION and VALUE.
C
 500  CONTINUE
      IF(QIX)THEN
        READ(PFILE,END=26,ERR=26)HUE,SAT,VALU
      ELSE
        READ(PFILE,*,END=26,ERR=26)HUE,SAT,VALU
      END IF
      SPOT=SPOT+1
      DLIST(UDFREE)=HUE/UNITS(UCHUE)
      DLIST(UDFREE+1)=SAT/UNITS(UCSAT)
      DLIST(UDFREE+2)=VALU/UNITS(UCVAL)
      UDFREE=UDFREE+3
      LENGTH=LENGTH+3
      GOTO 10
C
C   SET THE LSPEED GIVEN IN LDM2.
C
 600  CONTINUE
      GOTO 10
C
C   CHANGE DEFAULT DIMENSION
C
 700  IF( (LDM2.GE.2).AND.(LDM2.LE.4) )THEN
        NDIM=LDM2
      ELSE
        GOTO 26
      END IF
      GOTO 10
C
C   SET THE INTENSITY.  NEXT LINE GIVES FRONT AND SIZE.
C
 800  CONTINUE
      IF(QIX)THEN
        READ(PFILE,END=26,ERR=26)IFRONT,ISIZE
      ELSE
        READ(PFILE,*,END=26,ERR=26)IFRONT,ISIZE
      END IF
      SPOT=SPOT+1
      DLIST(UDFREE)=IFRONT
      DLIST(UDFREE+1)=ISIZE
      UDFREE=UDFREE+2
      LENGTH=LENGTH+2
      GOTO 10
C
C  Set the sphere radius
C   INFO ALREADY STORED AS N,LDM1,LDM2
C
 900  CONTINUE
      GOTO 10
C
C   WE REACHED THE END OF THIS OBJECT BEFORE REACHING
C   THE END OF FILE.  RETURN THE NEGATIVE OF THE COUNT
C   OF NUMBER OF LINES READ TO SIGNIFY THIS.
C   THIS IS HOW FRAMED FILE INPUT IS DONE.
C
 998  CONTINUE
      GETDSK=-SPOT
      RETURN
C
C   NORMAL RETURN.  FUNCTION RETURNS NUMBER OF LINES READ.
C
 999  CONTINUE
      GETDSK=SPOT
      IF (PFILE .NE. STDIN) CLOSE (UNIT=PFILE)
      RETURN
C
      END
