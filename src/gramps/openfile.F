C *************************************************************
C This file contains source code for the gMol computer program
C  Copyright (C) 1981-2010 by TJ O'Donnell and
C  Copyright (C) 2005-2010 gNova, Inc.
C It is unlawful to modify or remove this copyright notice.
C See the accompanying LICENSE file for further information. 
C *************************************************************
      FUNCTION OPENFILE(FILE,NUNIT,WRITEABLE,ACCMODE)
C
      IMPLICIT NONE
      INTEGER NUNIT
      CHARACTER FILE*(*)
      CHARACTER ACCMODE*(*)
      LOGICAL WRITEABLE
C
      CHARACTER AFILE*255
      CHARACTER*1 BLANK
#include "FILES.FOR"
#include "UDLIST.FOR"
#include "ERRORS.FOR"
      CHARACTER*3 EXT
      INTEGER I
      LOGICAL THERE
      LOGICAL DIRGVN
      INTEGER GETDIR
      INTEGER DIREND, DIRLEN, NAMELEN, NAMEEND, ILAST
      CHARACTER LNAME*39, LREST*39
      EXTERNAL TRIM
      SAVE DIRLEN,NAMELEN
      DATA BLANK/' '/
      BLANK=' '
C
      OPENFILE=0
      FULLFILE=' '
C
      DIREND=GETDIR( FILE, DIR, .FALSE. )
C
      IF(DIR.EQ.BLANK)THEN
        DIRGVN=.FALSE.
        IF(DEFDIR.EQ.BLANK)THEN
          DIR='./'
        ELSE
           I = GETDIR( DEFDIR, DIR, .TRUE. )
        END IF
      ELSE
        DIRGVN=.TRUE.
      END IF
C
      NAMEEND=INDEX(FILE(DIREND+1:),'.')
      IF(NAMEEND.NE.0)THEN
        NAME=FILE(DIREND+1:DIREND+NAMEEND-1)
        REST=FILE(DIREND+NAMEEND+1:)
      ELSE
        NAME=FILE(DIREND+1:)
        REST=DEFEXT
      END IF
C
      DIRLEN=trim(DIR)
      NAMELEN=trim(NAME)
      IF(NAMELEN.EQ.0)THEN
        OPENFILE=NONAME
        RETURN
      END IF
C     IF(NAMELEN.LT.0)NAMELEN=LEN(NAME)
C
C   WE MAY RETURN HERE IF THE USER REQUESTED ONLY PARSE
C   AND ALLOW RE-ENTRY AFTERWARDS.
C
      IF(ACCMODE.EQ.'PARSE')THEN
        AFILE = DIR(1:DIRLEN) // '/' // NAME(1:NAMELEN) // '.' // REST
        FULLFILE = AFILE
        RETURN
      END IF
C
C  ENTRY OPENFILX(FILE,NUNIT,WRITEABLE,ACCMODE)
C
C   THIS CONTINUE MARKS THE SPOT WHERE ANOTHER TRY
C   WILL BE MADE USING GRAMPSLIB DIRECTORY.
C
 10   CONTINUE
      EXT=REST(1:3)
      AFILE = DIR(1:DIRLEN) // '/' // NAME(1:NAMELEN) // '.' // REST
      INQUIRE(FILE=AFILE, EXIST=THERE)
      IF(.NOT.THERE)THEN
         LNAME=NAME
         LREST=REST
         CALL LOCASE(LNAME)
         CALL LOCASE(LREST)
         AFILE = DIR(1:DIRLEN) // '/' // LNAME(1:NAMELEN)
     &     // '.' // LREST
      END IF
      CALL UPCASE(EXT)
C
C   NOW TRY AND OPEN THE FILE.  THE METHOD OF
C   OPENING DEPENDS ON THE FILE TYPE AND THE
C   ARGUMENTS TO THIS SUBROUTINE, NAMELY
C   WRITEABLE AND ACCMODE (ACCESS_MODE).
C
C   UNFORMATTED USED FOR .QIX FILES or .RGB files.
C   .GIN FILES MAY BE EITHER READ OR WRITTEN DEPENDING
C   ON WHETHER THE COMMAND WAS 'DO' OR 'SET COLLECT'
C   ALSO SET COLLECT COULD WANT TO APPEND TO A .GIN FILE.
C
      IF(WRITEABLE)THEN
        IF(ACCMODE.EQ.'APPEND')THEN
          IF(EXT.EQ.'QIX' .OR. EXT.EQ.'RGB')THEN
            OPEN(UNIT=NUNIT,FILE=AFILE,ERR=999,
     &    ACCESS='APPEND',
     &    STATUS='OLD', FORM='UNFORMATTED')
          ELSE
            OPEN(UNIT=NUNIT,FILE=AFILE,ERR=999,
     &    ACCESS='APPEND',
     &    STATUS='OLD')
C    &    STATUS='OLD', CARRIAGECONTROL='LIST')
          END IF
        ELSE
          IF(EXT.EQ.'QIX' .OR. EXT.EQ.'RGB')THEN
            OPEN(UNIT=NUNIT,FILE=AFILE,ERR=999,
     &    FORM='UNFORMATTED',STATUS='UNKNOWN')
          ELSE
            OPEN(UNIT=NUNIT,FILE=AFILE,ERR=999,
     &  STATUS='UNKNOWN')
          END IF
        END IF
      ELSE
        IF(EXT.EQ.'QIX' .OR. EXT.EQ.'RGB')THEN
          OPEN(UNIT=NUNIT,FILE=AFILE,ERR=999,FORM='UNFORMATTED',
     &  STATUS='OLD')
C    &  STATUS='OLD',READONLY)
        ELSE
          OPEN(UNIT=NUNIT,FILE=AFILE,ERR=999,FORM='FORMATTED',
     &  STATUS='OLD')
C    &  STATUS='OLD',READONLY)
        END IF
      END IF
      OPENFILE=0
      FULLFILE=AFILE
      ILAST=trim(FULLFILE)
c  FULLFILE(ILAST+1:ILAST+1)=CHAR(0)
      RETURN
C
C   ERROR IF THE FILE IS NOT OPENABLE, ASSUME FILE NOT FOUND.
C   TRY ONE LAST TIME WITH THE LIBRARY DIRECTORY,
C   UNLESS WE'VE ALREADY TRIED BEFORE (OPENFILE ALREADY=FILNOT),
C  OR THE DIR WAS EXPLICITLY GIVEN IN THE FILE SPEC,
C   OR UNLESS THIS IS A WRITEABLE FILE.
C
 999  CONTINUE
      FULLFILE=' '
      IF(DIRGVN)OPENFILE=FILNOT
      IF(OPENFILE.EQ.FILNOT)THEN
        RETURN
      ELSE
        OPENFILE=FILNOT
        IF(WRITEABLE)RETURN
      END IF
      IF(GRLIB.NE.BLANK)THEN
        DIRLEN = GETDIR( GRLIB, DIR, .TRUE. )
        DIRLEN = trim(DIR)
        GOTO 10
      ELSE
        RETURN
      END IF
      END
C
      INTEGER FUNCTION GETDIR( FILE, DIR, ISDIR )
C
      CHARACTER*(*) FILE, DIR
      LOGICAL ISDIR
      Character*100 ENVDIR
      INTEGER NSLASH,ESTART,CSTART
      Integer TRIM
      External TRIM
C
C  PARSE UNIX STYLE DIRECTORY INFO FROM
C  1) A FULL FILE NAME IF ISDIR=FALSE
C  2) A DIRECTORY NAME IF ISDIR=TRUE
C  IT ALLOWS FOR A $ AS FIRST CHAR AND/OR : AS LAST CHAR
C  TO SIGNIFY ENVIRONMENT VARIABLE TO TRANSLATE.
C
      GETDIR=0
      DIR=' '
      ESTART=0
      CSTART=0

C Old style VMS dirs
C     GETDIR=INDEX(FILE,':')

      IF(FILE(1:1).EQ.'$')THEN
        GETDIR=INDEX(FILE,'/')
        If(GETDIR.EQ.0)GETDIR=TRIM(FILE)+1
        CALL GETENV( FILE(2:GETDIR-1), DIR )
        ESTART=TRIM(DIR)
        If (DIR(ESTART:ESTART) .NE. '/') Then
           DIR(ESTART+1:) = '/'
          ESTART=TRIM(DIR)
        End If
        CSTART=GETDIR
      END IF

 2    NSLASH = INDEX(FILE(GETDIR+1:),'/')
      IF(NSLASH.GT.0)THEN
        GETDIR=GETDIR + NSLASH
        GOTO 2
      ELSE
        IF(ISDIR .AND. GETDIR.GT.0)THEN
          NSLASH=INDEX(FILE(GETDIR+1:),' ')
          IF(NSLASH.GT.1)GETDIR=GETDIR+NSLASH
        END IF
      END IF
      IF(GETDIR.GT.0)DIR(ESTART+1:)=FILE(CSTART+1:GETDIR)
C
      RETURN
      END
