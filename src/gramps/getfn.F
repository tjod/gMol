C *************************************************************
C This file contains source code for the gMol computer program
C  Copyright (C) 1981-2010 by TJ O'Donnell and
C  Copyright (C) 2005-2010 gNova, Inc.
C It is unlawful to modify or remove this copyright notice.
C See the accompanying LICENSE file for further information. 
C *************************************************************
      SUBROUTINE GETFN(ARG,SPOINT)
C
      IMPLICIT NONE
C
#include "UDLIST.FOR"
#include "ERRORS.FOR"
C
      CHARACTER ARG*(*)
      CHARACTER*40 FUNC
      LOGICAL LESSTHAN
	INTEGER SPOINT, VPOINT
	INTEGER DLIM, IID, MPOINT, FPOINT, COL
	LOGICAL ADDER
	INTEGER LTGT, LTGT2, SQBR, BKSL
	REAL LEFT, RIGHT, LOWER, UPPER
	Integer NCOORD
C
      EQUIVALENCE (VAL,LOWER),(STEP,UPPER)
C
      CHARACTER*1  COMMA,BLANK
      COMMA=','
      BLANK=' '
C
C       THIS IS A GRAMPS UTILITY SUBROUTINE THAT PARSES THE
C       COMMAND STRING FOR A SPECIAL FUNCTION.  IT RETURNS
C       (IN COMMON /ARGITEM/) ANY DEVICES USED IN THE FUNCTION,
C       THE TYPE OF FUNCTION (FUNKY), ANY BOUNDS OR OTHER
C       VAULES GIVEN (LOWER, UPPER, VAL, STEP), WHETHER THE
C       VALUE IS AN OFFSET FROM A CURRENT VALUE (ADDIT),
C       ANY DIVIDING FACTOR (DFACT) FOR A DEV.
C
C       THE COMMAND POINTER IS UPDATED TO THE NEXT ARG OR
C       TO ZERO IF THIS WAS THE LAST ARG
C       OTHERWISE, THE POINTER IS NOT ALTERED.
C
C       ENTRY INTO THIS ROUTINE ASSUMES THAT THE POINT(ER) IS
C       POINTING AT THE PREVIOUS DELIMITER, NAMELY COMMA OR BLANK.
C       SKIP THIS DELIMITER AND LOOK FOR THE NEXT COMMA.
C       THE FUNCTION IS INBETWEEN THESE TWO DELIMITERS.
C
C
C       ASSUME THAT THERE'S NO SPECIAL FUNCTION
C
      FUNKY=0
      DEV=0
      VAL=0
      ADDIT=.FALSE.
      GOTVAL=.FALSE.
      STEP=0
      ADDSTEP=.FALSE.
      FACTOR=1.
C
C       LETS ISOLATE THE FUNCTION BY EXTRACTING IT FROM
C       THE COMMAND STRING.  I'LL WANT TO CHANGE THE
C       STRING AROUND A BIT, BUT NOT WITHIN THE COMMAND LINE!
C       SO EXTRACT THE FUNCTION USING GETSTR.
C       SAVE THE ARG POINTERS IN CASE WE FAIL IN
C       EVALUATING THIS STRING AS A FN.
C
      VPOINT=SPOINT
      CALL GETSTR(ARG,SPOINT,FUNC)
C
C	Could be an update from an existing object's coordinates.
C
      IF(FUNC(1:1).EQ.'@')THEN
        DLIM=INDEX(FUNC(2:),'@')
        IF(DLIM.EQ.0)THEN
          IID=IDNAME(FUNC(2:))
          STEP=1
        ELSE
          IID=IDNAME(FUNC(2:DLIM))
	  If(FUNC(DLIM+2:).EQ.BLANK)Then
		STEP=0
	  Else
		STEP=A2F(FUNC(DLIM+2:), ERROR)
		IF(ERROR.NE.0)CALL TELLUSER(-ABS(ERROR), *98)
	  End If
          IF(STEP.LE.0)STEP=1
        END IF
        IF(IID.EQ.0)CALL TELLUSER(-OBJERR,*98)
        VAL=IID
        FUNKY=IOR(FUNKY,FOBJ)
        FUNKY=IOR(FUNKY,FADDINC)
        GOTO 99
      END IF
C       
C	go on to other options (case insensitively)
C
      CALL UPCASE(FUNC)
      IF(ERROR.NE.0)GOTO 98
      MPOINT=NPOINT
C
C	Could be an update from point variable.
C
      	FPOINT=1
	Call GETCOORD(FUNC,FPOINT,NCOORD)
	If(ERROR.EQ.0)Then
		FUNKY=IOR(FUNKY,FCOORD)
		VAL=NCOORD
		Goto 99
	End If
C
C       MAYBE ITS A SIMPLE FUNCTION
C       OF JUST A DIAL (NEGATIVE OR FACTOR OF A DIAL)
C Check this first because -d1 is equivalent to -0.0D+01
C
      FPOINT=1
      CALL GETFDEV(FUNC,FPOINT)
      IF(ERROR.EQ.0)GOTO 99
      ERROR=0
C
C      FPOINT=1
C      CALL GETDEV(FUNC,FPOINT,DEV)
C      IF(ERROR.EQ.0)GOTO 99
C      ERROR=0
C
C       NO?! WELL, MAYBE ITS JUST A VALUE.
C
      FPOINT=1
      CALL GETVLX(FUNC,FPOINT,VAL,ADDIT)
      IF(ERROR.EQ.0)THEN
        GOTVAL=.TRUE.
        GOTO 99
      END IF
      ERROR=0
C
C       IT MUST BE A MORE COMPLICATED FUNCTION.
C       OR A COLON UPDATE TO A LIMIT
C
      COL=INDEX(FUNC,':')
      IF(COL.NE.0)THEN
        FUNC(COL:COL)=COMMA
        FPOINT=1
        CALL GETVLX(FUNC,FPOINT,VAL,ADDIT)
        IF(ERROR.NE.0)GOTO 98
        IF(FUNC(COL+1:COL+1).EQ.'S')THEN
          FUNKY=IOR(FUNKY,FSIN)
          FPOINT=FPOINT+1
        END IF
        CALL GETVLX(FUNC,FPOINT,STEP,ADDER)
        IF(ERROR.EQ.INCOMP)THEN
          ERROR=0
          STEP=0
        END IF
        IF(ERROR.NE.0)GOTO 98
        IF(STEP.LE.0)THEN
          STEP=0
          GOTVAL=.TRUE.
          FUNKY=0
        ELSE
          FUNKY=IOR(FUNKY,IOR(FLIMIT,FADDINC))
        END IF
        GOTO 99
      END IF
C
C       OR A BOUNDED DIAL ASSIGNMENT
C
      LTGT=INDEX(FUNC,'<')
      IF(LTGT.EQ.0)THEN
        LTGT=INDEX(FUNC,'>')
        IF(LTGT.EQ.0)GOTO 98
        LTGT2=LTGT + INDEX(FUNC(LTGT+1:),'>') 
        LESSTHAN=.FALSE.
      ELSE
        IF(INDEX(FUNC,'>').NE.0)GOTO 97
        LTGT2=LTGT + INDEX(FUNC(LTGT+1:),'<')
        LESSTHAN=.TRUE.
      END IF
      FUNC(LTGT:LTGT)=COMMA
      IF(LTGT2.NE.LTGT)FUNC(LTGT2:LTGT2)=COMMA
      IF(FUNC(1:1).EQ.'[')THEN
        SQBR=INDEX(FUNC,']')
        IF(SQBR.EQ.0)GOTO 97
        FUNKY=IOR(FUNKY,FBOUNCE)
        FUNC(SQBR:SQBR)=BLANK
        FPOINT=2
      ELSE IF(FUNC(1:1).EQ.'\\')THEN
        BKSL=INDEX(FUNC(2:),'\\')
        IF(BKSL.EQ.0)GOTO 97
        FUNKY=IOR(FUNKY,FWRAP)
	BKSL=BKSL+1
        FUNC(BKSL:BKSL)=BLANK
        FPOINT=2
      ELSE
        FPOINT=1
      END IF
      IF(LESSTHAN)THEN
        LEFT=-1.
        RIGHT=1.
      ELSE
        LEFT=1.
        RIGHT=-1.
      END IF
      CALL GETFDEV(FUNC,FPOINT)
      IF(ERROR.NE.0)THEN
        CALL GETVLX(FUNC,FPOINT,LEFT,ADDIT)
        IF(ERROR.NE.0)GOTO 97
        CALL GETFDEV(FUNC,FPOINT)
        IF(ERROR.NE.0)GOTO 98
        IF(LTGT2.NE.LTGT)THEN
          CALL GETVLX(FUNC,FPOINT,RIGHT,ADDSTEP)
          IF(ERROR.NE.0)GOTO 97
        END IF
      ELSE
        CALL GETVLX(FUNC,FPOINT,RIGHT,ADDSTEP)
        IF(ERROR.NE.0)GOTO 97
      END IF
      IF(LESSTHAN)THEN
        IF(LEFT.GT.RIGHT)GOTO 97
        LOWER=LEFT
        UPPER=RIGHT
      ELSE
        IF(LEFT.LT.RIGHT)GOTO 97
        LOWER=RIGHT
        UPPER=LEFT
      END IF
      FUNKY=IOR(FUNKY,FBOUNDED)
      GOTO 99
C
C       ERROR EXIT POINTS
C
 97   ERROR=BADBOUND
      SPOINT=VPOINT
      NPOINT=MPOINT
      RETURN
C
 98   ERROR=DVFERR
      SPOINT=VPOINT
      NPOINT=MPOINT
      RETURN
C
C      NORMAL EXIT POINT
C
 99   ERROR=0
      RETURN
C
      END
C
C
      SUBROUTINE GETFDEV(FUNC,FPOINT)
C
      IMPLICIT NONE
C
#include "UDLIST.FOR"
#include "ERRORS.FOR"
C#include "DEVICES.FOR"
C
      CHARACTER FUNC*(*)
	INTEGER FPOINT
C
      CHARACTER*40 FUNK
      CHARACTER*1 NEG,COMMA
      CHARACTER*10 RVAL
	INTEGER VPOINT, OP, PNT
      LOGICAL DIV
C     INTEGER DEV
      NEG='-'
      COMMA=','
C
C       THIS ROUTINE PARSES A STRING FOR A DIAL FUNCTION
C       THE ARG POINTER IS UPDATED PAST THE FUNCTION.
C       IF THERE'S AN ERROR NO ARG POINTER UPDATE IS DONE.
C
C       SAVE THE ARG POINTER AND EXTRACT THE FUNCTION
C       USING GETSTR.
C
      VPOINT=FPOINT
      CALL GETSTR(FUNC,FPOINT,FUNK)
      CALL UPCASE(FUNK)
      IF(ERROR.NE.0)GOTO 98
C
C       SUPPOSE ITS JUST A DEVICE WITH NO FUNCTION
C
      PNT=1
      CALL GETDEV(FUNK,PNT,DEV)
      IF(ERROR.EQ.0)GOTO 99
C
C       GUESS NOT...
C       SEE IF ITS A NEGATIVE OF A DEVICE
C
      IF(FUNK(1:1).EQ.NEG)THEN
        PNT=2
        CALL GETDEV(FUNK,PNT,DEV)
        IF(ERROR.EQ.0)THEN
          FUNKY=IOR(FUNKY,FNEGDEV)
          GOTO 99
        END IF
      END IF
C
C       TRY A DIVIDING FACTOR OF THE DEVICE
C
      OP=INDEX(FUNK,'/')
      IF(OP.NE.0)THEN
        DIV=.TRUE.
      ELSE
        OP=INDEX(FUNK,'*')
        IF(OP.EQ.0) GOTO 98
        DIV=.FALSE.
      END IF
      FUNK(OP:OP)=COMMA
      IF(FUNK(1:1).EQ.NEG)THEN
        PNT=2
        CALL GETDEV(FUNK,PNT,DEV)
        IF(ERROR.NE.0)GOTO 98
        FUNKY=IOR(FUNKY,FNEGDEV)
      ELSE
        PNT=1
        CALL GETDEV(FUNK,PNT,DEV)
      END IF
      CALL GETSTR(FUNK,PNT,RVAL)
      IF(ERROR.NE.0)GOTO 98
      FACTOR=A2F(RVAL,ERROR)
      IF(DIV)FACTOR=1./FACTOR
      IF(ERROR.NE.0)GOTO 98
      FUNKY=IOR(FUNKY,FFACT)
      GOTO 99
C
C       WE'VE EXHAUSTED ALL THE POSSIBILITIES. ERROR!
C
 98   ERROR=DVFERR
      FPOINT=VPOINT
      RETURN
C
C       THIS IS THE EXIT POINT IF NO ERROR HAS BEEN FOUND
C       UPDATE THE POINTER AND FLAG NO ERROR.
C
 99   ERROR=0
      RETURN
C
      END
